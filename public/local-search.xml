<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>useEffect 完整指南</title>
    <link href="/2021/12/02/aboutUseEffect/"/>
    <url>/2021/12/02/aboutUseEffect/</url>
    
    <content type="html"><![CDATA[<h2 id="useEffect-完整指南"><a href="#useEffect-完整指南" class="headerlink" title="useEffect 完整指南"></a>useEffect 完整指南</h2><p>你用<code>Hooks</code>写了一些组件，甚或写了一个小型应用。你可能很满意，使用它的API很舒服并且在这个过程中获得了一些小技巧。你甚至可能写了一些 <code>custom Hooks</code>去抽离重复的逻辑（精简掉了300行代码），并且得意地展示给你的同事看，“干得漂亮”，他们如是说。</p><p>但有时候当你使用<code>useEffect</code>你总觉得哪儿有点不对劲。你会嘀咕你可能遗漏了什么。它看起来像class的生命周期…但真的是这样吗？你发觉自己在问类似下面的这些问题：</p><ol><li> 如何用<code>useEffect</code>模拟<code>componentDidMount</code>生命周期？</li><li> 如何正确地在<code>useEffect</code>里请求数据？<code>[]</code>又是什么？</li><li> 我应该把函数当做effect的依赖吗？</li><li> 为什么有时候会出现无限重复请求的问题？</li><li> 为什么有时候在effect里拿到的是旧的state或prop？</li></ol><p>当我刚开始使用Hooks的时候，我也同样被上面这些问题所困扰。甚至当我写最初的文档时，我也并没有扎实地掌握某些细节。我经历了一些“啊哈”的开窍时刻，我想把这些分享给你。<b>这篇文章会深入讲解帮你明白上面问题的答案。</b></p><p>在看答案之前，我们需要先往后退一步。这篇文章的目的不是给你一个要点清单，而是想帮你真正地领会<code>useEffect</code>。其实我们并没有太多需要学习的，事实上，我们会花很多时间试图忘记某些已经习得的概念（unlearning）。</p><p><b>当我不再透过熟悉的class生命周期方法去窥视useEffect 这个Hook的时候，我才得以融会贯通。</b></p><blockquote><p>“忘记你已经学到的。” — Yoda</p></blockquote><hr><p><strong>这篇文章会假设你对<code>useEffect API</code>有一定程度的了解。</strong></p><p><strong>这篇文章真的很长。它更像一本mini书，这也是我更喜欢的形式。如果你很匆忙或者并不是太关心本文主题的话，你也可以直接看下面的摘要。</strong></p><p><strong>如果你对于深入研究感觉不是很适应的话，你或许可以等下面这些解释出现在其他文章中再去了解也行。就像2013年React刚出世的时候，大家需要时间去理解消化一种不同的心智模型。知识也需要时间去普及。</strong></p><hr><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>如果你不想阅读整篇文章，可以快速浏览这份摘要。要是某些部分不容易理解，你可以往下滚动寻找相关的内容去阅读。</p><p>如果你打算阅读整篇文章，你完全可以跳过这部分。我会在文章末尾带上摘要的链接。</p><p><strong>🤔 Question: 如何用useEffect模拟componentDidMount生命周期？</strong></p><p>虽然可以使用<code>useEffect(fn, [])</code>，但它们并不完全相等。和<code>componentDidMount</code>不一样，<code>useEffect</code>会捕获 <code>props</code>和<code>state</code>。所以即便在回调函数里，你拿到的还是初始的<code>props</code>和<code>state</code>。如果你想得到“最新”的值，你可以使用<code>ref</code>。不过，通常会有更简单的实现方式，所以你并不一定要用<code>ref</code>。记住，<code>effects</code>的心智模型和<code>componentDidMount</code>以及其他生命周期是不同的，试图找到它们之间完全一致的表达反而更容易使你混淆。想要更有效，你需要<code>“think in effects”</code>，它的心智模型更接近于实现状态同步，而不是响应生命周期事件。</p><p><strong>🤔 Question: 如何正确地在useEffect里请求数据？[]又是什么？</strong></p><p><a href="https://www.robinwieruch.de/react-hooks-fetch-data/">这篇文章</a>是很好的入门，介绍了如何在useEffect里做数据请求。请务必读完它！它没有我的这篇这么长。[] 表示effect没有使用任何React数据流里的值，因此该effect仅被调用一次是安全的。[]同样也是一类常见问题的来源，也即你以为没使用数据流里的值但其实使用了。你需要学习一些策略（主要是<code>useReducer</code> 和 <code>useCallback</code>）来移除这些effect依赖，而不是错误地忽略它们。</p><p><strong>🤔 Question: 我应该把函数当做effect的依赖吗？</strong></p><p>一般建议把不依赖<code>props</code>和<code>state</code>的函数提到你的组件外面，并且把那些仅被effect使用的函数放到effect里面。如果这样做了以后，你的effect还是需要用到组件内的函数（包括通过<code>props</code>传进来的函数），可以在定义它们的地方用<code>useCallback</code>包一层。为什么要这样做呢？因为这些函数可以访问到<code>props</code>和<code>state</code>，因此它们会参与到数据流中。我们官网的FAQ有<a href="https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">更详细的答案</a>。</p><p><strong>🤔 Question: 为什么有时候会出现无限重复请求的问题？</strong></p><p>这个通常发生于你在effect里做数据请求并且没有设置effect依赖参数的情况。没有设置依赖，effect会在每次渲染后执行一次，然后在effect中更新了状态引起渲染并再次触发effect。无限循环的发生也可能是因为你设置的依赖总是会改变。你可以通过一个一个移除的方式排查出哪个依赖导致了问题。但是，移除你使用的依赖（或者盲目地使用[]）通常是一种错误的解决方式。你应该做的是解决问题的根源。举个例子，函数可能会导致这个问题，你可以把它们放到effect里，或者提到组件外面，或者用<code>useCallback</code>包一层。<code>useMemo</code> 可以做类似的事情以避免重复生成对象。</p><p><strong>🤔 为什么有时候在effect里拿到的是旧的state或prop呢？</strong></p><p>Effect拿到的总是定义它的那次渲染中的props和state。这能够避免一些<a href="https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/">bugs</a>，但在一些场景中又会有些讨人嫌。对于这些场景，你可以明确地使用可变的ref保存一些值（上面文章的末尾解释了这一点）。如果你觉得在渲染中拿到了一些旧的props和state，且不是你想要的，你很可能遗漏了一些依赖。可以尝试使用这个<a href="https://github.com/facebook/react/issues/14920">lint 规则</a>来训练你发现这些依赖。可能没过几天，这种能力会变得像是你的第二天性。同样可以看我们官网FAQ中的<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function">这个回答</a>。</p><hr><h3 id="每一次渲染都有它自己的-Props-and-State"><a href="#每一次渲染都有它自己的-Props-and-State" class="headerlink" title="每一次渲染都有它自己的 Props and State"></a>每一次渲染都有它自己的 Props and State</h3><p>在我们讨论effects之前，我们需要先讨论一下渲染（rendering）。</p><p>我们来看一个计数器组件Counter，注意第6行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>第6行的代码究竟是什么意思呢？count 会“监听”状态的变化并自动更新吗？这么想可能是学习React的时候有用的第一直觉，但它并不是<a href="https://overreacted.io/zh-hans/react-as-a-ui-runtime/">精确的心智模型</a>。</p><p><strong>上面例子中，count仅是一个数字而已。</strong> 它不是神奇的“data binding”, “watcher”, “proxy”，或者其他任何东西。它就是一个普通的数字像下面这个一样：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">42</span>;<br><span class="hljs-comment">// ...</span><br>&lt;p&gt;You clicked &#123;<span class="hljs-keyword">count</span>&#125; times&lt;/p&gt;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>我们的组件第一次渲染的时候，从<code>useState()</code>拿到<code>count</code>的初始值0。当我们调用<code>setCount(1)</code>，React会再次渲染组件，这一次count是1。如此等等</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> During first render<br><span class="hljs-keyword">function</span> Counter() &#123;<br>  const count = <span class="hljs-number">0</span>; <span class="hljs-regexp">//</span> Returned by useState()<br>  <span class="hljs-regexp">//</span> ...<br>  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;<br>  <span class="hljs-regexp">//</span> ...<br>&#125;<br><br><span class="hljs-regexp">//</span> After a click, our <span class="hljs-keyword">function</span> is called again<br><span class="hljs-keyword">function</span> Counter() &#123;<br>  const count = <span class="hljs-number">1</span>; <span class="hljs-regexp">//</span> Returned by useState()<br>  <span class="hljs-regexp">//</span> ...<br>  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;<br>  <span class="hljs-regexp">//</span> ...<br>&#125;<br><br><span class="hljs-regexp">//</span> After another click, our <span class="hljs-keyword">function</span> is called again<br><span class="hljs-keyword">function</span> Counter() &#123;<br>  const count = <span class="hljs-number">2</span>; <span class="hljs-regexp">//</span> Returned by useState()<br>  <span class="hljs-regexp">//</span> ...<br>  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;<br>  <span class="hljs-regexp">//</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当我们更新状态的时候，React会重新渲染组件。每一次渲染都能拿到独立的count 状态，这个状态值是函数中的一个常量。</strong></p><p>所以下面的这行代码没有做任何特殊的数据绑定：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;p&gt;</span>You <span class="hljs-class">clicked </span>&#123;count&#125; times<span class="hljs-params">&lt;/p&gt;</span><br></code></pre></td></tr></table></figure><p><strong>它仅仅只是在渲染输出中插入了count这个数字。</strong> 这个数字由React提供。当<code>setCount</code>的时候，React会带着一个不同的<code>count</code>值再次调用组件。然后，React会更新DOM以保持和渲染输出一致。</p><p>这里关键的点在于任意一次渲染中的<code>count</code>常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的<code>count</code>值独立于其他渲染。</p><h3 id="每一次渲染都有它自己的事件处理函数"><a href="#每一次渲染都有它自己的事件处理函数" class="headerlink" title="每一次渲染都有它自己的事件处理函数"></a>每一次渲染都有它自己的事件处理函数</h3><p>到目前为止一切都还好。那么事件处理函数呢？</p><p>看下面的这个例子。它在三秒后会<code>alert</code>点击次数<code>count</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAlertClick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      alert(<span class="hljs-string">&#x27;You clicked on: &#x27;</span> + count);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleAlertClick&#125;</span>&gt;</span></span><br><span class="xml">        Show alert</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我按照下面的步骤去操作：</p><ol><li><strong>点击增加</strong> counter到3</li><li><strong>点击一下</strong> “Show alert”</li><li><strong>点击增加</strong> counter到5并且在定时器回调触发前完成</li></ol><p><img src="https://s3.bmp.ovh/imgs/2021/12/1f749462b7a173f1.gif"></p><p>你猜alert会弹出什么呢？会是5吗？— 这个值是alert的时候counter的实时状态。或者会是3吗？— 这个值是我点击时候的状态。</p><hr><p>剧透预警</p><hr><p>来自己 <a href="https://codesandbox.io/s/w2wxl3yo0l">试试吧！</a></p><p>如果结果和你预料不一样，你可以想象一个更实际的例子：一个聊天应用在state中保存了当前接收者的ID，以及一个发送按钮。 <a href="https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/">这篇文章</a> 深入探索了个中缘由。正确的答案就是3。</p><p><code>alert</code>会“捕获”我点击按钮时候的状态。</p><p><em>（虽然有其他办法可以实现不同的行为，但现在我会专注于这个默认的场景。当我们在构建一种心智模型的时候，在可选的策略中分辨出“最小阻力路径”是非常重要的。）</em></p><hr><p>但它究竟是如何工作的呢？</p><p>我们发现count在每一次函数调用中都是一个常量值。值得强调的是 <strong>— 我们的组件函数每次渲染都会被调用，但是每一次调用中count值都是常量，并且它被赋予了当前渲染中的状态值。</strong></p><p>这并不是React特有的，普通的函数也有类似的行为：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> sayHi(person) &#123;<br>  const<span class="hljs-built_in"> name</span> = person<span class="hljs-built_in">.name</span>;<br>  setTimeout(() =&gt; &#123;<br>    alert(<span class="hljs-string">&#x27;Hello, &#x27;</span> +<span class="hljs-built_in"> name</span>);<br>  &#125;, <span class="hljs-number">3000</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> someone = <span class="hljs-built_in">&#123;name</span>: <span class="hljs-string">&#x27;Dan&#x27;</span>&#125;;<br>sayHi(someone);<br><br>someone = <span class="hljs-built_in">&#123;name</span>: <span class="hljs-string">&#x27;Yuzhi&#x27;</span>&#125;;<br>sayHi(someone);<br><br>someone = <span class="hljs-built_in">&#123;name</span>: <span class="hljs-string">&#x27;Dominic&#x27;</span>&#125;;<br>sayHi(someone);<br><br></code></pre></td></tr></table></figure><p>在 <a href="https://codesandbox.io/s/mm6ww11lk8">这个例子</a>中, 外层的<code>someone</code>会被赋值很多次（就像在React中，当前的组件状态会改变一样）。然后，<strong>在<code>sayHi</code>函数中，局部常量name会和某次调用中的<code>person</code>关联。</strong>因为这个常量是局部的，所以每一次调用都是相互独立的。结果就是，当定时器回调触发的时候，每一个<code>alert</code>都会弹出它拥有的<code>name</code>。</p><p>这就解释了我们的事件处理函数如何捕获了点击时候的<code>count</code>值。如果我们应用相同的替换原理，每一次渲染“看到”的是它自己的<code>count</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// During first render</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// Returned by useState()</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAlertClick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      alert(<span class="hljs-string">&#x27;You clicked on: &#x27;</span> + count);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// After a click, our function is called again</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">// Returned by useState()</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAlertClick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      alert(<span class="hljs-string">&#x27;You clicked on: &#x27;</span> + count);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// After another click, our function is called again</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> count = <span class="hljs-number">2</span>; <span class="hljs-comment">// Returned by useState()</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAlertClick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      alert(<span class="hljs-string">&#x27;You clicked on: &#x27;</span> + count);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>所以实际上，每一次渲染都有一个“新版本”的<code>handleAlertClick</code>。每一个版本的<code>handleAlertClick</code>“记住” 了它自己的 count：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// During first render</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAlertClick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      alert(<span class="hljs-string">&#x27;You clicked on: &#x27;</span> + <span class="hljs-number">0</span>);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>  &lt;button onClick=&#123;handleAlertClick&#125; /&gt; <span class="hljs-comment">// The one with 0 inside</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// After a click, our function is called again</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAlertClick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      alert(<span class="hljs-string">&#x27;You clicked on: &#x27;</span> + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>  &lt;button onClick=&#123;handleAlertClick&#125; /&gt; <span class="hljs-comment">// The one with 1 inside</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// After another click, our function is called again</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAlertClick</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      alert(<span class="hljs-string">&#x27;You clicked on: &#x27;</span> + <span class="hljs-number">2</span>);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>  &lt;button onClick=&#123;handleAlertClick&#125; /&gt; <span class="hljs-comment">// The one with 2 inside</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这就是为什么在<a href="https://codesandbox.io/s/w2wxl3yo0l">这个demo</a>中，事件处理函数“属于”某一次特定的渲染，当你点击的时候，它会使用那次渲染中<code>counter</code>的状态值。</p><p><strong>在任意一次渲染中，props和state是始终保持不变的。</strong>如果props和state在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的<code>count</code>值。</p><p><em>备注：上面我将具体的count值直接内联到了<code>handleAlertClick</code>函数中。这种心智上的替换是安全的因为count 值在某次特定渲染中不可能被改变。它被声明成了一个常量并且是一个数字。这样去思考其他类型的值比如对象也同样是安全的，当然需要在我们都同意应该避免直接修改state这个前提下。通过调用<code>setSomething(newObj)</code>的方式去生成一个新的对象而不是直接修改它是更好的选择，因为这样能保证之前渲染中的<code>state</code>不会被污染。</em></p><h3 id="每次渲染都有它自己的Effects"><a href="#每次渲染都有它自己的Effects" class="headerlink" title="每次渲染都有它自己的Effects"></a>每次渲染都有它自己的Effects</h3><p>这篇文章是关于effects的，但目前我们居然还没有讨论effects！ 言归正传，由上面的分析得出一个结果，effects其实并没有什么两样。</p><p>让我们回到<a href="https://zh-hans.reactjs.org/docs/hooks-effect.html">官网文档</a>中的这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>抛一个问题给你：effect是如何读取到最新的count 状态值的呢？</strong></p><p>也许，是某种“data binding”或“watching”机制使得<code>count</code>能够在effect函数内更新？也或许<code>count</code>是一个可变的值，React会在我们组件内部修改它以使我们的effect函数总能拿到最新的值？</p><p>都不是。</p><p>我们已经知道<code>count</code>是某个特定渲染中的常量。事件处理函数“看到”的是属于它那次特定渲染中的<code>count</code>状态值。对于effects也同样如此：</p><p><strong>并不是<code>count</code>的值在“不变”的effect中发生了改变，而是effect 函数本身在每一次渲染中都不相同</strong></p><p>每一个effect版本“看到”的<code>count</code>值都来自于它属于的那次渲染：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> During first render<br><span class="hljs-keyword">function</span> Counter() &#123;<br>  <span class="hljs-regexp">//</span> ...<br>  useEffect(<br>    <span class="hljs-regexp">//</span> Effect <span class="hljs-keyword">function</span> from first render<br>    () =&gt; &#123;<br>      document.title = `You clicked <span class="hljs-variable">$&#123;0&#125;</span> times`;<br>    &#125;<br>  );<br>  <span class="hljs-regexp">//</span> ...<br>&#125;<br><br><span class="hljs-regexp">//</span> After a click, our <span class="hljs-keyword">function</span> is called again<br><span class="hljs-keyword">function</span> Counter() &#123;<br>  <span class="hljs-regexp">//</span> ...<br>  useEffect(<br>    <span class="hljs-regexp">//</span> Effect <span class="hljs-keyword">function</span> from second render<br>    () =&gt; &#123;<br>      document.title = `You clicked <span class="hljs-variable">$&#123;1&#125;</span> times`;<br>    &#125;<br>  );<br>  <span class="hljs-regexp">//</span> ...<br>&#125;<br><br><span class="hljs-regexp">//</span> After another click, our <span class="hljs-keyword">function</span> is called again<br><span class="hljs-keyword">function</span> Counter() &#123;<br>  <span class="hljs-regexp">//</span> ...<br>  useEffect(<br>    <span class="hljs-regexp">//</span> Effect <span class="hljs-keyword">function</span> from third render<br>    () =&gt; &#123;<br>      document.title = `You clicked <span class="hljs-variable">$&#123;2&#125;</span> times`;<br>    &#125;<br>  );<br>  <span class="hljs-regexp">//</span> ..<br>&#125;<br></code></pre></td></tr></table></figure><p>React会记住你提供的effect函数，并且会在每次更改作用于DOM并让浏览器绘制屏幕后去调用它。</p><p>所以虽然我们说的是一个 effect（这里指更新document的title），但其实每次渲染都是一个不同的函数 — 并且每个effect函数“看到”的props和state都来自于它属于的那次特定渲染。</p><p><strong>概念上，你可以想象effects是渲染结果的一部分。</strong></p><p>严格地说，它们并不是（为了<a href="https://overreacted.io/zh-hans/why-do-hooks-rely-on-call-order/">允许Hook的组合</a>并且不引入笨拙的语法或者运行时）。但是在我们构建的心智模型上，effect函数属于某个特定的渲染，就像事件处理函数一样。</p><p>为了确保我们已经有了扎实的理解，我们再回顾一下第一次的渲染过程：</p><ul><li><p><strong>React:</strong> 给我状态为 0时候的UI。</p></li><li><p>你的组件:</p><ul><li>给你需要渲染的内容: <code>&lt;p&gt;You clicked 0 times&lt;/p&gt;</code>。</li><li>记得在渲染完了之后调用这个<code>effect: () =&gt; &#123; document.title = &#39;You clicked 0 times&#39; &#125;</code>。</li></ul></li><li><p>**React:**没问题。开始更新UI，喂浏览器，我要给DOM添加一些东西。</p></li><li><p><strong>浏览器:</strong> 酷，我已经把它绘制到屏幕上了。</p></li><li><p><strong>React:</strong> 好的， 我现在开始运行给我的effect</p><ul><li>运行 <code>() =&gt; &#123; document.title = &#39;You clicked 0 times&#39; &#125;</code>。</li></ul></li></ul><hr><p>现在我们回顾一下我们点击之后发生了什么：</p><ul><li><p><strong>你的组件:</strong> 喂 React, 把我的状态设置为1</p></li><li><p><strong>React:</strong> 给我状态为 1时候的UI。</p></li><li><p><strong>你的组件:</strong></p><ul><li>给你需要渲染的内容: <code>&lt;p&gt;You clicked 1 times&lt;/p&gt;</code>。</li><li>记得在渲染完了之后调用这个effect：<code> () =&gt; &#123; document.title = &#39;You clicked 1 times&#39; &#125;</code>。</li></ul></li><li><p><strong>React:</strong> 没问题。开始更新UI，喂浏览器，我修改了DOM。</p></li><li><p><strong>Browser:</strong> 酷，我已经将更改绘制到屏幕上了。</p></li><li><p><strong>React:</strong> 好的， 我现在开始运行属于这次渲染的effect</p><ul><li>运行 <code>() =&gt; &#123; document.title = &#39;You clicked 1 times&#39; &#125;</code>。</li></ul></li></ul><hr><h3 id="每一次渲染都有它自己的…所有"><a href="#每一次渲染都有它自己的…所有" class="headerlink" title="每一次渲染都有它自己的…所有"></a>每一次渲染都有它自己的…所有</h3><p><strong>我们现在知道effects会在每次渲染后运行，并且概念上它是组件输出的一部分，可以“看到”属于某次特定渲染的props和state。</strong></p><p>我们来做一个思想实验，思考下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked &#123;count&#125; times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;</span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我点击了很多次并且在effect里设置了延时，打印出来的结果会是什么呢？</p><hr><p><em>剧透预警</em></p><hr><p>你可能会认为这是一个很绕的题并且结果是反直觉的。完全错了！我们看到的就是顺序的打印输出 — 每一个都属于某次特定的渲染，因此有它该有的<code>count</code>值。你可以<a href="https://codesandbox.io/s/lyx20m1ol">自己试一试</a>：</p><p><img src="https://s3.bmp.ovh/imgs/2021/12/3c270e05942f5087.gif"></p><p>你可能会想：“它当然应该是这样的。否则还会怎么样呢？”</p><p>不过，class中的<code>this.state</code>并不是这样运作的。你可能会想当然以为下面的class 实现和上面是相等的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.count&#125;</span> times`</span>);<br>   &#125;, <span class="hljs-number">3000</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p>然而，<code>this.state.count</code>总是指向最新的<code>count</code>值，而不是属于某次特定渲染的值。所以你会看到每次打印输出都是<code>5</code>：</p><p><img src="https://s3.bmp.ovh/imgs/2021/12/dc111a1973003bdf.gif"></p><p>我觉得Hooks这么依赖Javascript闭包是挺讽刺的一件事。有时候组件的class实现方式会受闭包相关的苦（the canonical wrong-value-in-a-timeout confusion），但其实这个例子中真正的混乱来源是可变数据（React 修改了class中的<code>this.state</code>使其指向最新状态），并不是闭包本身的错。</p><p><strong>当封闭的值始终不会变的情况下闭包是非常棒的。这使它们非常容易思考因为你本质上在引用常量</strong>。正如我们所讨论的，props和state在某个特定渲染中是不会改变的。顺便说一下，我们可以<a href="https://codesandbox.io/s/w7vjo07055">使用闭包</a>修复上面的class版本…</p><h3 id="逆潮而动"><a href="#逆潮而动" class="headerlink" title="逆潮而动"></a>逆潮而动</h3><p>到目前为止，我们可以明确地喊出下面重要的事实：每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props和state。</p><p>所以下面的两个例子是相等的：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>function Example(props) &#123;<br>  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(props.counter);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>  <span class="hljs-regexp">//</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">function Example(props) &#123;<br>  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(props.counter);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>  <span class="hljs-regexp">//</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在组件内什么时候去读取props或者state是无关紧要的。</strong> 因为它们不会改变。在单次渲染的范围内，props和state始终保持不变。（解构赋值的props使得这一点更明显。）</p><p>当然，有时候你可能想在effect的回调函数里读取最新的值而不是捕获的值。最简单的实现方法是使用refs，<a href="https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/">这篇文章</a>的最后一部分介绍了相关内容。</p><p>需要注意的是当你想要从过去渲染中的函数里读取未来的props和state，你是在逆潮而动。虽然它并没有错（有时候可能也需要这样做），但它因为打破了默认范式会使代码显得不够“干净”。这是我们有意为之的，因为它能帮助突出哪些代码是脆弱的，是需要依赖时间次序的。在class中，如果发生这种情况就没那么显而易见了。</p><p>下面这个<a href="https://codesandbox.io/s/rm7z22qnlp">计数器版本</a> 模拟了class中的行为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> latestCount = useRef(count);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// Set the mutable latest value</span><br>    latestCount.current = count;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// Read the mutable latest value</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;latestCount.current&#125;</span> times`</span>);<br>    &#125;, <span class="hljs-number">3000</span>);<br>  &#125;);<br>  <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2021/12/63dd13b023498b23.gif"></p><p>在React中去直接修改值看上去有点怪异。然而，在class组件中React正是这样去修改<code>this.state</code>的。不像捕获的props和state，你没法保证在任意一个回调函数中读取的<code>latestCount.current</code>是不变的。根据定义，你可以随时修改它。这就是为什么它不是默认行为，而是需要你主动选择这样做。</p><h3 id="那Effect中的清理又是怎样的呢？"><a href="#那Effect中的清理又是怎样的呢？" class="headerlink" title="那Effect中的清理又是怎样的呢？"></a>那Effect中的清理又是怎样的呢？</h3><p>像 <a href="https://zh-hans.reactjs.org/docs/hooks-effect.html#effects-with-cleanup">文档中解释</a>的, 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用（effect)，比如取消订阅。</p><p>思考下面的代码:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>subscribe<span class="hljs-constructor">ToFriendStatus(<span class="hljs-params">props</span>.<span class="hljs-params">id</span>, <span class="hljs-params">handleStatusChange</span>)</span>;<br>    return<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br>      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ChatAPI</span>.</span></span>unsubscribe<span class="hljs-constructor">FromFriendStatus(<span class="hljs-params">props</span>.<span class="hljs-params">id</span>, <span class="hljs-params">handleStatusChange</span>)</span>;<br>    &#125;;<br>  &#125;);<br></code></pre></td></tr></table></figure><p>假设第一次渲染的时候props是<code>&#123;id: 10&#125;</code>，第二次渲染的时候是<code>&#123;id: 20&#125;</code>。你可能会认为发生了下面的这些事：</p><ul><li><strong>React</strong>  清除了 {id: 10}的effect。</li><li><strong>React</strong>  渲染{id: 20}的UI。</li><li><strong>React</strong>  运行{id: 20}的effect。</li></ul><p>(事实并不是这样。)</p><p>如果依赖这种心智模型，你可能会认为清除过程“看到”的是旧的props因为它是在重新渲染之前运行的，新的effect“看到”的是新的props因为它是在重新渲染之后运行的。这种心智模型直接来源于class组件的生命周期。不过<strong>它并不精确</strong>。让我们来一探究竟。</p><p>React只会在浏览器绘制后运行effects。这使得你的应用更流畅因为大多数effects并不会阻塞屏幕的更新。Effect的清除同样被延迟了。<strong>上一次的effect会在重新渲染后被清除</strong>：</p><ul><li><strong>React 渲染<code>&#123;id: 20&#125;</code>的UI。</strong></li><li>浏览器绘制。我们在屏幕上看到<code>&#123;id: 20&#125;</code>的UI。</li><li><strong>React 清除{id: 10}的effect。</strong></li><li><strong>React</strong> 运行<code>&#123;id: 20&#125;</code>的effect</li></ul><p>你可能会好奇：如果清除上一次的effect发生在props变成<code>&#123;id: 20&#125;</code>之后，那它为什么还能“看到”旧的<code>&#123;id: 10&#125;</code>？</p><p>引用上半部分得到的结论:</p><blockquote><p><em>组件内的每一个函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获定义它们的那次渲染中的props和state。</em></p></blockquote><p>现在答案显而易见。effect的清除并不会读取“最新”的props。它只能读取到定义它的那次渲染中的props值：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// First render, props are &#123;id: 10&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  useEffect(<br>    <span class="hljs-comment">// Effect from first render</span><br>    () =&gt; &#123;<br>      ChatAPI.subscribeToFriendStatus(<span class="hljs-number">10</span>, handleStatusChange);<br>      <span class="hljs-comment">// Cleanup for effect from first render</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        ChatAPI.unsubscribeFromFriendStatus(<span class="hljs-number">10</span>, handleStatusChange);<br>      &#125;;<br>    &#125;<br>  );<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// Next render, props are &#123;id: 20&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  useEffect(<br>    <span class="hljs-comment">// Effect from second render</span><br>    () =&gt; &#123;<br>      ChatAPI.subscribeToFriendStatus(<span class="hljs-number">20</span>, handleStatusChange);<br>      <span class="hljs-comment">// Cleanup for effect from second render</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        ChatAPI.unsubscribeFromFriendStatus(<span class="hljs-number">20</span>, handleStatusChange);<br>      &#125;;<br>    &#125;<br>  );<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>王国会崛起转而复归尘土，太阳会脱落外层变为白矮星，最后的文明也迟早会结束。但是第一次渲染中effect的清除函数只能看到<code>&#123;id: 10&#125;</code>这个props。</p><p>这正是为什么React能做到在绘制后立即处理effects — 并且默认情况下使你的应用运行更流畅。如果你的代码需要依然可以访问到老的props。</p><h3 id="同步，-而非生命周期"><a href="#同步，-而非生命周期" class="headerlink" title="同步， 而非生命周期"></a>同步， 而非生命周期</h3><p>我最喜欢React的一点是它统一描述了初始渲染和之后的更新。这降低了你程序的熵。</p><p>比如我有个组件像下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">&#123; name &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Greeting&quot;</span>&gt;</span></span><br><span class="xml">      Hello, &#123;name&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  );<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我先渲染<code>&lt;Greeting name=&quot;Dan&quot; /&gt;</code>然后渲染<code>&lt;Greeting name=&quot;Yuzhi&quot; /&gt;</code>，和我直接渲染<code>&lt;Greeting name=&quot;Yuzhi&quot; /&gt;</code>并没有什么区别。在这两种情况中，我最后看到的都是“Hello, Yuzhi”。</p><p>人们总是说：“重要的是旅行过程，而不是目的地”。在React世界中，恰好相反。<strong>重要的是目的，而不是过程。</strong> 这就是JQuery代码中 <code>$.addClass </code>或 <code>$.removeClass</code>这样的调用（过程）和React代码中声明<strong>CSS类名</strong>应该是什么（目的）之间的区别。</p><p><strong>React会根据我们当前的<code>props</code>和<code>state</code>同步到DOM。</strong> “<code>mount</code>”和“<code>update</code>”之于渲染并没有什么区别。</p><p>你应该以相同的方式去思考effects。**<code>useEffect</code>使你能够根据props和state同步React tree之外的东西。**</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">&#123; name &#125;</span>) </span>&#123;<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">&#x27;Hello, &#x27;</span> + name;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Greeting&quot;</span>&gt;</span></span><br><span class="xml">      Hello, &#123;name&#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是和大家熟知的<code>mount/update/unmount</code>心智模型之间细微的区别。理解和内化这种区别是非常重要的。<strong>如果你试图写一个effect会根据是否第一次渲染而表现不一致，你正在逆潮而动。</strong>如果我们的结果依赖于过程而不是目的，我们会在同步中犯错。</p><p>先渲染属性A，B再渲染C，和立即渲染C并没有什么区别。虽然他们可能短暂地会有点不同（比如请求数据时），但最终的结果是一样的。</p><p>不过话说回来，在<strong>每一次</strong>渲染后都去运行所有的effects可能并不高效。（并且在某些场景下，它可能会导致无限循环。）</p><p>所以我们该怎么解决这个问题？</p><h4 id="告诉React去比对你的Effects"><a href="#告诉React去比对你的Effects" class="headerlink" title="告诉React去比对你的Effects"></a>告诉React去比对你的Effects</h4><p>其实我们已经从React处理DOM的方式中学习到了解决办法。React只会更新DOM真正发生改变的部分，而不是每次渲染都大动干戈。</p><p>当你把</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Greeting&quot;</span>&gt;</span><br>  Hello, Dan<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>更新到</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Greeting&quot;</span>&gt;</span><br>  Hello, Yuzhi<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>React 能够看到两个对象:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const oldProps</span> = &#123;className: <span class="hljs-string">&#x27;Greeting&#x27;</span>, children: <span class="hljs-string">&#x27;Hello, Dan&#x27;</span>&#125;;<br><span class="hljs-attribute">const newProps</span> = &#123;className: <span class="hljs-string">&#x27;Greeting&#x27;</span>, children: <span class="hljs-string">&#x27;Hello, Yuzhi&#x27;</span>&#125;;<br></code></pre></td></tr></table></figure><p>它会检测每一个props，并且发现children发生改变需要更新DOM，但<code>className</code>并没有。所以它只需要这样做：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">domNode.innerText = <span class="hljs-string">&#x27;Hello, Yuzhi&#x27;</span>;<br><span class="hljs-regexp">//</span> No need to touch domNode.className<br></code></pre></td></tr></table></figure><p><strong>我们也可以用类似的方式处理effects吗？如果能够在不需要的时候避免调用effect就太好了。</strong></p><p>举个例子，我们的组件可能因为状态变更而重新渲染：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">&#123; name &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [counter, setCounter] = useState(<span class="hljs-number">0</span>);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">&#x27;Hello, &#x27;</span> + name;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;Greeting&quot;</span>&gt;</span></span><br><span class="xml">      Hello, &#123;name&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCounter(counter + 1)&#125;&gt;</span><br><span class="xml">        Increment</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>但是我们的effect并没有使用<code>counter</code>这个状态。<strong>我们的<code>effect</code>只会同步<code>name</code>属性给<code>document.title</code>，但<code>name</code>并没有变。</strong>在每一次<code>counter</code>改变后重新给<code>document.title</code>赋值并不是理想的做法。</p><p>好了，那React可以…区分effects的不同吗？</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let oldEffect = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-built_in">document</span>.title = <span class="hljs-string">&#x27;Hello, Dan&#x27;</span>; &#125;;<br>let newEffect = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-built_in">document</span>.title = <span class="hljs-string">&#x27;Hello, Dan&#x27;</span>; &#125;;<br><span class="hljs-regexp">//</span> Can React see these functions <span class="hljs-keyword">do</span> the same thing?<br></code></pre></td></tr></table></figure><p>并不能。React并不能猜测到函数做了什么如果不先调用的话。（源码中并没有包含特殊的值，它仅仅是引用了<code>name</code>属性。）</p><p>这是为什么你如果想要避免effects不必要的重复调用，你可以提供给<code>useEffect</code>一个依赖数组参数(deps)：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">document</span>.title = <span class="hljs-string">&#x27;Hello, &#x27;</span> + name;<br>&#125;, [name]); <span class="hljs-regexp">//</span> Our deps<br></code></pre></td></tr></table></figure><p><strong>这好比你告诉React：“Hey，我知道你看不到这个函数里的东西，但我可以保证只使用了渲染中的name，别无其他。”</strong></p><p>如果当前渲染中的这些依赖项和上一次运行这个effect的时候值一样，因为没有什么需要同步React会自动跳过这次effect：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> oldEffect = () =&gt; &#123; <span class="hljs-built_in">document</span>.title = <span class="hljs-string">&#x27;Hello, Dan&#x27;</span>; &#125;;<br><span class="hljs-keyword">const</span> oldDeps = [<span class="hljs-string">&#x27;Dan&#x27;</span>];<br><br><span class="hljs-keyword">const</span> newEffect = () =&gt; &#123; <span class="hljs-built_in">document</span>.title = <span class="hljs-string">&#x27;Hello, Dan&#x27;</span>; &#125;;<br><span class="hljs-keyword">const</span> newDeps = [<span class="hljs-string">&#x27;Dan&#x27;</span>];<br><br><span class="hljs-comment">// React can&#x27;t peek inside of functions, but it can compare deps.</span><br><span class="hljs-comment">// Since all deps are the same, it doesn’t need to run the new effect.</span><br></code></pre></td></tr></table></figure><p>即使依赖数组中只有一个值在两次渲染中不一样，我们也不能跳过effect的运行。要同步所有！</p><h4 id="关于依赖项不要对React撒谎"><a href="#关于依赖项不要对React撒谎" class="headerlink" title="关于依赖项不要对React撒谎"></a>关于依赖项不要对React撒谎</h4><p>关于依赖项对React撒谎会有不好的结果。直觉上，这很好理解，但我曾看到几乎所有依赖class心智模型使用<code>useEffect</code>的人都试图违反这个规则。（我刚开始也这么干了！）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchResults</span>(<span class="hljs-params"></span>) </span>&#123;<br>  async <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br><br>  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    fetchData();<br>  &#125;, []); <span class="hljs-comment">// Is this okay? Not always -- and there&#x27;s a better way to write it.</span><br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(官网的 <a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies">Hooks FAQ</a> 解释了应该怎么做。 我们在下面会重新回顾这个例子。)</p><p>“但我只是想在挂载的时候运行它！”，你可能会说。现在只需要记住：如果你设置了依赖项，<strong>effect中用到的所有组件内的值都要包含在依赖中</strong>这包括props，state，函数 — 组件内的任何东西。</p><p>有时候你是这样做了，但可能会引起一个问题。比如，你可能会遇到无限请求的问题，或者socket被频繁创建的问题。<strong>解决问题的方法不是移除依赖项。</strong> 我们会很快了解具体的解决方案。</p><p>不过在我们深入解决方案之前，我们先尝试更好地理解问题。</p><h4 id="如果设置了错误的依赖会怎么样呢？"><a href="#如果设置了错误的依赖会怎么样呢？" class="headerlink" title="如果设置了错误的依赖会怎么样呢？"></a>如果设置了错误的依赖会怎么样呢？</h4><p>如果依赖项包含了所有effect中使用到的值，React就能知道何时需要运行它：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>   <span class="hljs-built_in">document</span>.title = <span class="hljs-string">&#x27;Hello, &#x27;</span> + name;<br> &#125;, [name]);<br><br></code></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2021/12/068eedbd4b62ba50.gif"></p><p>(依赖发生了变更，所以会重新运行effect。)</p><p>但是如果我们将[]设为effect的依赖，新的effect函数不会运行：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">document</span>.title = <span class="hljs-string">&#x27;Hello, &#x27;</span> + name;<br>&#125;, []); <span class="hljs-regexp">//</span> Wrong: name <span class="hljs-keyword">is</span> missing <span class="hljs-keyword">in</span> deps<br><br></code></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2021/12/f9f57ffe14269120.gif"></p><p>(依赖没有变，所以不会再次运行effect。)</p><p>在这个例子中，问题看起来显而易见。但在某些情况下如果你脑子里“跳出”class组件的解决办法，你的直觉很可能会欺骗你。</p><p>举个例子，我们来写一个每秒递增的计数器。在Class组件中，我们的直觉是：“开启一次定时器，清除也是一次”。这里有一个<a href="https://codesandbox.io/s/n5mjzjy9kl">例子</a>说明怎么实现它。当我们理所当然地把它用<code>useEffect</code>的方式翻译，直觉上我们会设置依赖为<code>[]</code>。“我只想运行一次effect”，对吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCount(count + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);<br>  &#125;, []);<br><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然而，这个例子<a href="https://codesandbox.io/s/91n5z8jo7r">只会递增一次</a>。<em>天了噜。</em></p><p>如果你的心智模型是“只有当我想重新触发effect的时候才需要去设置依赖”，这个例子可能会让你产生存在危机。你想要触发一次因为它是定时器 — 但为什么会有问题？</p><p>如果你知道依赖是我们给React的暗示，告诉它effect所有需要使用的渲染中的值，你就不会吃惊了。effect中使用了count但我们撒谎说它没有依赖。如果我们这样做迟早会出幺蛾子。</p><p>在第一次渲染中，<code>count</code>是<code>0</code>。因此，<code>setCount(count + 1)</code>在第一次渲染中等价于<code>setCount(0 + 1)</code>。既然我们设置了<code>[]</code>依赖，effect不会再重新运行，它后面每一秒都会调用<code>setCount(0 + 1)</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// First render, state is 0</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  useEffect(<br>    <span class="hljs-comment">// Effect from first render</span><br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        setCount(<span class="hljs-number">0</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// Always setCount(1)</span><br>      &#125;, <span class="hljs-number">1000</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);<br>    &#125;,<br>    [] <span class="hljs-comment">// Never re-runs</span><br>  );<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// Every next render, state is 1</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  useEffect(<br>    <span class="hljs-comment">// This effect is always ignored because</span><br>    <span class="hljs-comment">// we lied to React about empty deps.</span><br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        setCount(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>);<br>      &#125;, <span class="hljs-number">1000</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);<br>    &#125;,<br>    []<br>  );<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们对React撒谎说我们的effect不依赖组件内的任何值，可实际上我们的effect有依赖！</p><p>我们的effect依赖count - 它是组件内的值（不过在effect外面定义）：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const count = <span class="hljs-regexp">//</span> ...<br><br>  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    const id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>      setCount(count + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> () =&gt; <span class="hljs-built_in">clearInterval</span>(id);<br>  &#125;, []);<br></code></pre></td></tr></table></figure><p>因此，设置[]为依赖会引入一个bug。React会对比依赖，并且跳过后面的effect：</p><p><img src="https://s3.bmp.ovh/imgs/2021/12/c9b7d2ac70d3cd92.gif"></p><p><em>(依赖没有变，所以不会再次运行effect。)</em></p><p>类似于这样的问题是很难被想到的。因此，我鼓励你将诚实地告知effect依赖作为一条硬性规则，并且要列出所以依赖。（我们提供了一个<a href="https://github.com/facebook/react/issues/14920">lint</a>规则如果你想在你的团队内做硬性规定。）</p><h4 id="两种诚实告知依赖的方法"><a href="#两种诚实告知依赖的方法" class="headerlink" title="两种诚实告知依赖的方法"></a>两种诚实告知依赖的方法</h4><p>有两种诚实告知依赖的策略。你应该从第一种开始，然后在需要的时候应用第二种。</p><p><strong>第一种策略是在依赖中包含所有effect中用到的组件内的值。</strong> 让我们在依赖中包含<code>count</code>：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  const id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    setCount(count + <span class="hljs-number">1</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>  <span class="hljs-keyword">return</span> () =&gt; <span class="hljs-built_in">clearInterval</span>(id);<br>&#125;, [count]);<br></code></pre></td></tr></table></figure><p>现在依赖数组正确了。虽然它可能不是太理想但确实解决了上面的问题。现在，每次<code>count</code>修改都会重新运行<code>effect</code>，并且定时器中的<code>setCount(count + 1)</code>会正确引用某次渲染中的 <code>count</code>值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// First render, state is 0</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  useEffect(<br>    <span class="hljs-comment">// Effect from first render</span><br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        setCount(<span class="hljs-number">0</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// setCount(count + 1)</span><br>      &#125;, <span class="hljs-number">1000</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);<br>    &#125;,<br>    [<span class="hljs-number">0</span>] <span class="hljs-comment">// [count]</span><br>  );<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// Second render, state is 1</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  useEffect(<br>    <span class="hljs-comment">// Effect from second render</span><br>    <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        setCount(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// setCount(count + 1)</span><br>      &#125;, <span class="hljs-number">1000</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);<br>    &#125;,<br>    [<span class="hljs-number">1</span>] <span class="hljs-comment">// [count]</span><br>  );<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这能<a href="https://codesandbox.io/s/0x0mnlyq8l">解决问题</a>但是我们的定时器会在每一次count改变后清除和重新设定。这应该不是我们想要的结果：</p><p><img src="https://s3.bmp.ovh/imgs/2021/12/dfa94d2d65ac6160.gif"></p><p><em>(依赖发生了变更，所以会重新运行effect。)</em></p><hr><p><strong>第二种策略是修改effect内部的代码以确保它包含的值只会在需要的时候发生变更。</strong> 我们不想告知错误的依赖 - 我们只是修改effect使得依赖更少。</p><p>让我们来看一些移除依赖的常用技巧。</p><hr><h4 id="让Effects自给自足"><a href="#让Effects自给自足" class="headerlink" title="让Effects自给自足"></a>让Effects自给自足</h4><p>我们想去掉effect的<code>count</code>依赖。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>   const id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>     setCount(count + <span class="hljs-number">1</span>);<br>   &#125;, <span class="hljs-number">1000</span>);<br>   <span class="hljs-keyword">return</span> () =&gt; <span class="hljs-built_in">clearInterval</span>(id);<br> &#125;, [count]);<br><br></code></pre></td></tr></table></figure><p>为了实现这个目的，我们需要问自己一个问题：<strong>我们为什么要用count？</strong> 可以看到我们只在<code>setCount</code>调用中用到了<code>count</code>。在这个场景中，我们其实并不需要在effect中使用<code>count</code>。当我们想要根据前一个状态更新状态的时候，我们可以使用setState的函数形式：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>   const id = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>     setCount(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>   &#125;, <span class="hljs-number">1000</span>);<br>   <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> clearInterval(id);<br> &#125;, []);<br></code></pre></td></tr></table></figure><p>我喜欢把类似这种情况称为“错误的依赖”。是的，因为我们在effect中写了<code>setCount(count + 1)</code>所以<code>count</code>是一个必需的依赖。但是，我们真正想要的是把<code>count</code>转换为<code>count+1</code>，然后返回给React。可是React其实已经知道当前的count。<strong>我们需要告知React的仅仅是去递增状态 - 不管它现在具体是什么值。</strong></p><p>这正是setCount(c =&gt; c + 1)做的事情。你可以认为它是在给React“发送指令”告知如何更新状态。这种“更新形式”在其他情况下也有帮助，比如你需要批量更新。</p><p><strong>注意我们做到了移除依赖，并且没有撒谎。我们的effect不再读取渲染中的count值。</strong></p><h4 id="函数式更新-和-Google-Docs"><a href="#函数式更新-和-Google-Docs" class="headerlink" title="函数式更新 和 Google Docs"></a>函数式更新 和 Google Docs</h4><p>还记得我们说过同步才是理解effects的心智模型吗？同步的一个有趣地方在于你通常想要把同步的“信息”和状态解耦。举个例子，当你在Google Docs编辑文档的时候，Google并不会把整篇文章发送给服务器。那样做会非常低效。相反的，它只是把你的修改以一种形式发送给服务端。</p><p>虽然我们effect的情况不尽相同，但可以应用类似的思想。只在effects中传递最小的信息会很有帮助。类似于<code>setCount(c =&gt; c + 1)</code>这样的更新形式比<code>setCount(count + 1)</code>传递了更少的信息，因为它不再被当前的count值“污染”。它只是表达了一种行为（“递增”）。“Thinking in React”也讨论了如何找到最小状态。原则是类似的，只不过现在关注的是如何更新。</p><p>表达意图（而不是结果）和Google Docs如何处理共同编辑异曲同工。虽然这个类比略微延伸了一点，函数式更新在React中扮演了类似的角色。它们确保能以批量地和可预测的方式来处理各种源头（事件处理函数，effect中的订阅，等等）的状态更新。</p><p>然而，即使是<code>setCount(c =&gt; c + 1)</code>也并不完美。它看起来有点怪，并且非常受限于它能做的事。举个例子，如果我们有两个互相依赖的状态，或者我们想基于一个<code>prop</code>来计算下一次的<code>state</code>，它并不能做到。幸运的是， <code>setCount(c =&gt; c + 1)</code>有一个更强大的姐妹模式，它的名字叫<code>useReducer</code>。</p><h4 id="解耦来自Actions的更新"><a href="#解耦来自Actions的更新" class="headerlink" title="解耦来自Actions的更新"></a>解耦来自Actions的更新</h4><p>我们来修改上面的例子让它包含两个状态：<code>count</code> 和 <code>step</code>。我们的定时器会每次在<code>count</code>上增加一个<code>step</code>值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> [step, setStep] = useState(<span class="hljs-number">1</span>);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCount(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + step);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);<br>  &#125;, [step]);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;step&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;e</span> =&gt;</span> setStep(Number(e.target.value))&#125; /&gt;</span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>(这里是<a href="https://codesandbox.io/s/zxn70rnkx">demo</a>.)</p><p>注意<strong>我们没有撒谎</strong>。既然我们在<code>effect</code>里使用了<code>step</code>，我们就把它加到依赖里。所以这也是为什么代码能运行正确。’</p><p>这个例子目前的行为是修改<code>step</code>会重启定时器 - 因为它是依赖项之一。在大多数场景下，这正是你所需要的。清除上一次的effect然后重新运行新的effect并没有任何错。除非我们有很好的理由，我们不应该改变这个默认行为。</p><p>不过，假如我们不想在<code>step</code>改变后重启定时器，我们该如何从effect中移除对<code>step</code>的依赖呢？</p><p><strong>当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用useReducer去替换它们。</strong></p><p>当你写类似<code>setSomething(something =&gt; ...)</code>这种代码的时候，也许就是考虑使用<code>reducer</code>的契机。<code>reducer</code>可以让你<strong>把组件内发生了什么(actions)和状态如何响应并更新分开表述。</strong></p><p>我们用一个<code>dispatch</code>依赖去替换effect的<code>step</code>依赖：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> [<span class="hljs-keyword">state</span>, dispatch] = useReducer(reducer, initialState);<br><span class="hljs-keyword">const</span> &#123; count, step &#125; = <span class="hljs-keyword">state</span>;<br><br>useEffect(() =&gt; &#123;<br>  <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">set</span>Interval(() =&gt; &#123;<br>    dispatch(&#123; type: &#x27;tick&#x27; &#125;); // Instead of <span class="hljs-built_in">set</span>Count(c =&gt; c + step);<br>  &#125;, <span class="hljs-number">1000</span>);<br>  return () =&gt; clearInterval(id);<br>&#125;, [dispatch]);<br></code></pre></td></tr></table></figure><p>(查看 <a href="https://codesandbox.io/s/xzr480k0np">demo</a>。)</p><p>你可能会问：“这怎么就更好了？”答案是<strong>React会保证dispatch在组件的声明周期内保持不变。所以上面例子中不再需要重新订阅定时器。</strong></p><p>我们解决了问题!</p><p>（<em>你可以从依赖中去除dispatch, setState, 和useRef包裹的值因为React会确保它们是静态的。不过你设置了它们作为依赖也没什么问题。</em>）</p><p>相比于直接在effect里面读取状态，它<code>dispatch</code>了一个<code>action</code>来描述发生了什么。这使得我们的effect和<code>step</code>状态解耦。我们的effect不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由reducer去统一处理:</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sqf">const initialState = &#123;<br>  <span class="hljs-built_in">count</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-built_in">step</span>: <span class="hljs-number">1</span>,<br>&#125;;<br><br>function reducer(state, <span class="hljs-built_in">action</span>) &#123;<br>  const &#123; <span class="hljs-built_in">count</span>, <span class="hljs-built_in">step</span> &#125; = state;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">action</span>.<span class="hljs-built_in">type</span> === <span class="hljs-string">&#x27;tick&#x27;</span>) &#123;<br>    return &#123; <span class="hljs-built_in">count</span>: <span class="hljs-built_in">count</span> + <span class="hljs-built_in">step</span>, <span class="hljs-built_in">step</span> &#125;;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">action</span>.<span class="hljs-built_in">type</span> === <span class="hljs-string">&#x27;step&#x27;</span>) &#123;<br>    return &#123; <span class="hljs-built_in">count</span>, <span class="hljs-built_in">step</span>: <span class="hljs-built_in">action</span>.<span class="hljs-built_in">step</span> &#125;;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">throw</span> new Error();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(这里是<a href="https://codesandbox.io/s/xzr480k0np">demo</a> 如果你之前错过了。)</p><h4 id="为什么useReducer是Hooks的作弊模式"><a href="#为什么useReducer是Hooks的作弊模式" class="headerlink" title="为什么useReducer是Hooks的作弊模式"></a>为什么useReducer是Hooks的作弊模式</h4><p>我们已经学习到如何移除effect的依赖，不管状态更新是依赖上一个状态还是依赖另一个状态。<strong>但假如我们需要依赖props去计算下一个状态呢？</strong>举个例子，也许我们的API是<code>&lt;Counter step=&#123;1&#125; /&gt;</code>。确定的是，在这种情况下，我们没法避免依赖<code>props.step</code> 。是吗？</p><p>实际上， 我们可以避免！我们可以把reducer函数放到组件内去读取props：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Counter</span>(<span class="hljs-params">&#123; step &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, dispatch] = useReducer(reducer, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reducer</span>(<span class="hljs-params">state, action</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (action.type === <span class="hljs-string">&#x27;tick&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> state + step;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();<br>    &#125;<br>  &#125;<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      dispatch(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;tick&#x27;</span> &#125;);<br>    &#125;, <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(id);<br>  &#125;, [dispatch]);<br><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种模式会使一些优化失效，所以你应该避免滥用它，不过如果你需要你完全可以在<code>reducer</code>里面访问<code>props</code>。（这里是<a href="https://codesandbox.io/s/7ypm405o8q">demo</a>。）</p><p>即使是在这个例子中，<strong>React也保证dispatch在每次渲染中都是一样的。</strong> 所以你可以在依赖中去掉它。它不会引起<code>effect</code>不必要的重复执行。</p><p>你可能会疑惑：这怎么可能？在之前渲染中调用的reducer怎么“知道”新的props？答案是当你dispatch的时候，React只是记住了action - 它会在下一次渲染中再次调用reducer。在那个时候，新的props就可以被访问到，而且reducer调用也不是在effect里。</p><p><strong>这就是为什么我倾向认为useReducer是Hooks的“作弊模式”。它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的effect调用。</strong></p><h3 id="把函数移到Effects里"><a href="#把函数移到Effects里" class="headerlink" title="把函数移到Effects里"></a>把函数移到Effects里</h3><p>一个典型的误解是认为函数不应该成为依赖。举个例子，下面的代码看上去可以运行正常：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">SearchResults()</span> &#123;<br>  const <span class="hljs-literal">[<span class="hljs-identifier">data</span>, <span class="hljs-identifier">setData</span>]</span> = use<span class="hljs-constructor">State(&#123; <span class="hljs-params">hits</span>: [] &#125;)</span>;<br><br>  async <span class="hljs-keyword">function</span> fetch<span class="hljs-constructor">Data()</span> &#123;<br>    const result = await axios(<br>      &#x27;https:<span class="hljs-comment">//hn.algolia.com/api/v1/search?query=react&#x27;,</span><br>    );<br>    set<span class="hljs-constructor">Data(<span class="hljs-params">result</span>.<span class="hljs-params">data</span>)</span>;<br>  &#125;<br><br>  use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br>    fetch<span class="hljs-constructor">Data()</span>;<br>  &#125;, <span class="hljs-literal">[]</span>); <span class="hljs-comment">// Is this okay?</span><br><br>  <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>需要明确的是，上面的代码可以正常工作。<strong>但这样做在组件日渐复杂的迭代过程中我们很难确保它在各种情况下还能正常运行。</strong></p><p>想象一下我们的代码做下面这样的分离，并且每一个函数的体量是现在的五倍：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">SearchResults()</span> &#123;<br>  <span class="hljs-comment">// Imagine this function is long</span><br>  <span class="hljs-keyword">function</span> get<span class="hljs-constructor">FetchUrl()</span> &#123;<br>    return &#x27;https:<span class="hljs-comment">//hn.algolia.com/api/v1/search?query=react&#x27;;</span><br>  &#125;<br><br>  <span class="hljs-comment">// Imagine this function is also long</span><br>  async <span class="hljs-keyword">function</span> fetch<span class="hljs-constructor">Data()</span> &#123;<br>    const result = await axios(get<span class="hljs-constructor">FetchUrl()</span>);<br>    set<span class="hljs-constructor">Data(<span class="hljs-params">result</span>.<span class="hljs-params">data</span>)</span>;<br>  &#125;<br><br>  use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br>    fetch<span class="hljs-constructor">Data()</span>;<br>  &#125;, <span class="hljs-literal">[]</span>);<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们在某些函数内使用了某些state或者prop：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">SearchResults()</span> &#123;<br>  const <span class="hljs-literal">[<span class="hljs-identifier">query</span>, <span class="hljs-identifier">setQuery</span>]</span> = use<span class="hljs-constructor">State(&#x27;<span class="hljs-params">react</span>&#x27;)</span>;<br><br>  <span class="hljs-comment">// Imagine this function is also long</span><br>  <span class="hljs-keyword">function</span> get<span class="hljs-constructor">FetchUrl()</span> &#123;<br>    return &#x27;https:<span class="hljs-comment">//hn.algolia.com/api/v1/search?query=&#x27; + query;</span><br>  &#125;<br><br>  <span class="hljs-comment">// Imagine this function is also long</span><br>  async <span class="hljs-keyword">function</span> fetch<span class="hljs-constructor">Data()</span> &#123;<br>    const result = await axios(get<span class="hljs-constructor">FetchUrl()</span>);<br>    set<span class="hljs-constructor">Data(<span class="hljs-params">result</span>.<span class="hljs-params">data</span>)</span>;<br>  &#125;<br><br>  use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br>    fetch<span class="hljs-constructor">Data()</span>;<br>  &#125;, <span class="hljs-literal">[]</span>);<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果我们忘记去更新使用这些函数（很可能通过其他函数调用）的effects的依赖，我们的effects就不会同步<code>props</code>和<code>state</code>带来的变更。这当然不是我们想要的。</p><p>幸运的是，对于这个问题有一个简单的解决方案。<strong>如果某些函数仅在effect中调用，你可以把它们的定义移到effect中：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">SearchResults()</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br>    <span class="hljs-comment">// We moved these functions inside!</span><br>    <span class="hljs-keyword">function</span> get<span class="hljs-constructor">FetchUrl()</span> &#123;<br>      return &#x27;https:<span class="hljs-comment">//hn.algolia.com/api/v1/search?query=react&#x27;;</span><br>    &#125;<br>    async <span class="hljs-keyword">function</span> fetch<span class="hljs-constructor">Data()</span> &#123;<br>      const result = await axios(get<span class="hljs-constructor">FetchUrl()</span>);<br>      set<span class="hljs-constructor">Data(<span class="hljs-params">result</span>.<span class="hljs-params">data</span>)</span>;<br>    &#125;<br><br>    fetch<span class="hljs-constructor">Data()</span>;<br>  &#125;, <span class="hljs-literal">[]</span>); <span class="hljs-comment">// ✅ Deps are OK</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(这里是<a href="https://codesandbox.io/s/04kp3jwwql">demo</a>.)</p><p>这么做有什么好处呢？我们不再需要去考虑这些“间接依赖”。我们的依赖数组也不再撒谎：<strong>在我们的effect中确实没有再使用组件范围内的任何东西。</strong></p><p>如果我们后面修改 <code>getFetchUrl</code>去使用<code>query</code>状态，我们更可能会意识到我们正在effect里面编辑它 - 因此，我们需要把<code>query</code>添加到effect的依赖里：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">SearchResults()</span> &#123;<br>  const <span class="hljs-literal">[<span class="hljs-identifier">query</span>, <span class="hljs-identifier">setQuery</span>]</span> = use<span class="hljs-constructor">State(&#x27;<span class="hljs-params">react</span>&#x27;)</span>;<br><br>  use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br>    <span class="hljs-keyword">function</span> get<span class="hljs-constructor">FetchUrl()</span> &#123;<br>      return &#x27;https:<span class="hljs-comment">//hn.algolia.com/api/v1/search?query=&#x27; + query;</span><br>    &#125;<br><br>    async <span class="hljs-keyword">function</span> fetch<span class="hljs-constructor">Data()</span> &#123;<br>      const result = await axios(get<span class="hljs-constructor">FetchUrl()</span>);<br>      set<span class="hljs-constructor">Data(<span class="hljs-params">result</span>.<span class="hljs-params">data</span>)</span>;<br>    &#125;<br><br>    fetch<span class="hljs-constructor">Data()</span>;<br>  &#125;, <span class="hljs-literal">[<span class="hljs-identifier">query</span>]</span>); <span class="hljs-comment">// ✅ Deps are OK</span><br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>(这里是<a href="https://codesandbox.io/s/pwm32zx7z7">demo</a>.)</p><p>添加这个依赖，我们不仅仅是在“取悦React”。在query改变后去重新请求数据是合理的。<code>useEffect</code>的设计意图就是要强迫你关注数据流的改变，然后决定我们的effects该如何和它同步 - 而不是忽视它直到我们的用户遇到了bug。</p><p>感谢<code>eslint-plugin-react-hooks</code> 插件的<code>exhaustive-depslint</code>规则，它会在你编码的时候就分析effects并且提供可能遗漏依赖的建议。换句话说，机器会告诉你组件中哪些数据流变更没有被正确地处理。</p><p><img src="https://s3.bmp.ovh/imgs/2021/12/acb01105d6349648.gif"></p><p>非常棒。</p><h3 id="但我不能把这个函数放到Effect里"><a href="#但我不能把这个函数放到Effect里" class="headerlink" title="但我不能把这个函数放到Effect里"></a>但我不能把这个函数放到Effect里</h3><p>有时候你可能不想把函数移入effect里。比如，组件内有几个effect使用了相同的函数，你不想在每个effect里复制黏贴一遍这个逻辑。也或许这个函数是一个prop。</p><p>在这种情况下你应该忽略对函数的依赖吗？我不这么认为。再次强调，<strong>effects不应该对它的依赖撒谎。</strong>通常我们还有更好的解决办法。一个常见的误解是，“函数从来不会改变”。但是这篇文章你读到现在，你知道这显然不是事实。实际上，在组件内定义的函数每一次渲染都在变。</p><p><strong>函数每次渲染都会改变这个事实本身就是个问题。</strong> 比如有两个effects会调用 <code>getFetchUrl</code>:</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchResults</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFetchUrl</span>(<span class="hljs-params">query</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;<br>  &#125;<br><br>  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    const url = getFetchUrl(<span class="hljs-string">&#x27;react&#x27;</span>);<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, []); <span class="hljs-comment">// 🔴 Missing dep: getFetchUrl</span><br><br>  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    const url = getFetchUrl(<span class="hljs-string">&#x27;redux&#x27;</span>);<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, []); <span class="hljs-comment">// 🔴 Missing dep: getFetchUrl</span><br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，你可能不想把<code>getFetchUrl</code> 移到effects中，因为你想复用逻辑。</p><p>另一方面，如果你对依赖很“诚实”，你可能会掉到陷阱里。我们的两个effects都依赖<code>getFetchUrl</code>，<strong>而它每次渲染都不同</strong>，所以我们的依赖数组会变得无用</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchResults</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 🔴 Re-triggers all effects on every render</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFetchUrl</span>(<span class="hljs-params">query</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;<br>  &#125;<br><br>  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    const url = getFetchUrl(<span class="hljs-string">&#x27;react&#x27;</span>);<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, [getFetchUrl]); <span class="hljs-comment">// 🚧 Deps are correct but they change too often</span><br><br>  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    const url = getFetchUrl(<span class="hljs-string">&#x27;redux&#x27;</span>);<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, [getFetchUrl]); <span class="hljs-comment">// 🚧 Deps are correct but they change too often</span><br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个可能的解决办法是把<code>getFetchUrl</code>从依赖中去掉。但是，我不认为这是好的解决方式。这会使我们后面对数据流的改变很难被发现从而忘记去处理。这会导致类似于上面“定时器不更新值”的问题。</p><p>相反的，我们有两个更简单的解决办法。</p><p><strong>第一个， 如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在effects中使用：</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// ✅ Not affected by the data flow</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFetchUrl</span>(<span class="hljs-params">query</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchResults</span>(<span class="hljs-params"></span>) </span>&#123;<br>  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    const url = getFetchUrl(<span class="hljs-string">&#x27;react&#x27;</span>);<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, []); <span class="hljs-comment">// ✅ Deps are OK</span><br><br>  useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    const url = getFetchUrl(<span class="hljs-string">&#x27;redux&#x27;</span>);<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, []); <span class="hljs-comment">// ✅ Deps are OK</span><br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于props或state。</p><p>或者， 你也可以把它包装成 <code>useCallback</code> Hook:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchResults</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ✅ Preserves identity when its own deps are the same</span><br>  <span class="hljs-keyword">const</span> getFetchUrl = useCallback(<span class="hljs-function">(<span class="hljs-params">query</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;<br>  &#125;, []);  <span class="hljs-comment">// ✅ Callback deps are OK</span><br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = getFetchUrl(<span class="hljs-string">&#x27;react&#x27;</span>);<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, [getFetchUrl]); <span class="hljs-comment">// ✅ Effect deps are OK</span><br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = getFetchUrl(<span class="hljs-string">&#x27;redux&#x27;</span>);<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, [getFetchUrl]); <span class="hljs-comment">// ✅ Effect deps are OK</span><br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>useCallback</code>本质上是添加了一层依赖检查。它以另一种方式解决了问题 - <strong>我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。</strong></p><p>我们来看看为什么这种方式是有用的。之前，我们的例子中展示了两种搜索结果（查询条件分别为’<code>react</code>‘和’<code>redux</code>‘）。但如果我们想添加一个输入框允许你输入任意的查询条件(<code>query</code>)。不同于传递<code>query</code>参数的方式，现在<code>getFetchUrl</code>会从状态中读取。</p><p>我们很快发现它遗漏了<code>query</code>依赖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchResults</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [query, setQuery] = useState(<span class="hljs-string">&#x27;react&#x27;</span>);<br>  <span class="hljs-keyword">const</span> getFetchUrl = useCallback(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// No query argument</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;<br>  &#125;, []); <span class="hljs-comment">// 🔴 Missing dep: query</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我把<code>query</code>添加到<code>useCallback</code> 的依赖中，任何调用了<code>getFetchUrl</code>的effect在<code>query</code>改变后都会重新运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SearchResults</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [query, setQuery] = useState(<span class="hljs-string">&#x27;react&#x27;</span>);<br><br>  <span class="hljs-comment">// ✅ Preserves identity until query changes</span><br>  <span class="hljs-keyword">const</span> getFetchUrl = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;<br>  &#125;, [query]);  <span class="hljs-comment">// ✅ Callback deps are OK</span><br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = getFetchUrl();<br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;, [getFetchUrl]); <span class="hljs-comment">// ✅ Effect deps are OK</span><br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们要感谢<code>useCallback</code>，因为如果<code>query</code> 保持不变，<code>getFetchUrl</code>也会保持不变，我们的effect也不会重新运行。但是如果query修改了，<code>getFetchUrl</code>也会随之改变，因此会重新请求数据。这就像你在Excel里修改了一个单元格的值，另一个使用它的单元格会自动重新计算一样。</p><p>这正是拥抱数据流和同步思维的结果。<strong>对于通过属性从父组件传入的函数这个方法也适用：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [query, setQuery] = useState(<span class="hljs-string">&#x27;react&#x27;</span>);<br><br>  <span class="hljs-comment">// ✅ Preserves identity until query changes</span><br>  <span class="hljs-keyword">const</span> fetchData = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> url = <span class="hljs-string">&#x27;https://hn.algolia.com/api/v1/search?query=&#x27;</span> + query;<br>    <span class="hljs-comment">// ... Fetch data and return it ...</span><br>  &#125;, [query]);  <span class="hljs-comment">// ✅ Callback deps are OK</span><br><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">fetchData</span>=<span class="hljs-string">&#123;fetchData&#125;</span> /&gt;</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">&#123; fetchData &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> [data, setData] = useState(<span class="hljs-literal">null</span>);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    fetchData().then(setData);<br>  &#125;, [fetchData]); <span class="hljs-comment">// ✅ Effect deps are OK</span><br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>fetchData</code>只有在Parent的<code>query</code>状态变更时才会改变，所以我们的Child只会在需要的时候才去重新请求数据。</p><h3 id="函数是数据流的一部分吗？"><a href="#函数是数据流的一部分吗？" class="headerlink" title="函数是数据流的一部分吗？"></a>函数是数据流的一部分吗？</h3><p>有趣的是，这种模式在class组件中行不通，并且这种行不通恰到好处地揭示了effect和生命周期范式之间的区别。考虑下面的转换：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    query: <span class="hljs-symbol">&#x27;reac</span>t&#x27;<br>  &#125;;<br>  fetchData = () =&gt; &#123;<br>    const url = <span class="hljs-symbol">&#x27;https</span>:<span class="hljs-comment">//hn.algolia.com/api/v1/search?query=&#x27; + this.state.query;</span><br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">Child</span> fetchData=&#123;<span class="hljs-keyword">this</span>.fetchData&#125; /&gt;;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    data: <span class="hljs-literal">null</span><br>  &#125;;<br>  componentDidMount() &#123;<br>    <span class="hljs-keyword">this</span>.props.fetchData();<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>你可能会想：“我们都知道<code>useEffect</code> 就像<code>componentDidMount</code> 和 <code>componentDidUpdate</code>的结合，你不能老是破坏这一条！”<strong>好吧，就算加了componentDidUpdate照样无用：</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    data: <span class="hljs-literal">null</span><br>  &#125;;<br>  componentDidMount() &#123;<br>    <span class="hljs-keyword">this</span>.props.fetchData();<br>  &#125;<br>  componentDidUpdate(prevProps) &#123;<br>    <span class="hljs-comment">// 🔴 This condition will never be true</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.fetchData !== prevProps.fetchData) &#123;<br>      <span class="hljs-keyword">this</span>.props.fetchData();<br>    &#125;<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然如此，<code>fetchData</code>是一个class方法！（或者你也可以说是class属性 - 但这不能改变什么。）它不会因为状态的改变而不同，所以<code>this.props.fetchData</code>和<code> prevProps.fetchData</code>始终相等，因此不会重新请求。那我们删掉条件判断怎么样？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params">prevProps</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.props.fetchData();<br>  &#125;<br></code></pre></td></tr></table></figure><p>等等，这样会在每次渲染后都去请求。(添加一个加载动画可能是一种有趣的发现这种情况的方式。)也许我们可以绑定一个特定的query?</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">render() &#123;<br>   <span class="hljs-keyword">return</span> &lt;Child fetchData=&#123;<span class="hljs-keyword">this</span>.fetchData.bind(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.state.query)&#125; /&gt;;<br> &#125;<br></code></pre></td></tr></table></figure><p>但这样一来，<code>this.props.fetchData !== prevProps.fetchData</code> 表达式永远是true，即使<code>query</code>并未改变。这会导致我们总是去请求。</p><p>想要解决这个class组件中的难题，唯一现实可行的办法是硬着头皮把<code>query</code>本身传入 Child 组件。 Child 虽然实际并没有直接使用这个<code>query</code>的值，但能在它改变的时候触发一次重新请求：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    query: <span class="hljs-symbol">&#x27;reac</span>t&#x27;<br>  &#125;;<br>  fetchData = () =&gt; &#123;<br>    const url = <span class="hljs-symbol">&#x27;https</span>:<span class="hljs-comment">//hn.algolia.com/api/v1/search?query=&#x27; + this.state.query;</span><br>    <span class="hljs-comment">// ... Fetch data and do something ...</span><br>  &#125;;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">Child</span> fetchData=&#123;<span class="hljs-keyword">this</span>.fetchData&#125; query=&#123;<span class="hljs-keyword">this</span>.state.query&#125; /&gt;;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    data: <span class="hljs-literal">null</span><br>  &#125;;<br>  componentDidMount() &#123;<br>    <span class="hljs-keyword">this</span>.props.fetchData();<br>  &#125;<br>  componentDidUpdate(prevProps) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.props.query !== prevProps.query) &#123;<br>      <span class="hljs-keyword">this</span>.props.fetchData();<br>    &#125;<br>  &#125;<br>  render() &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用React的class组件这么多年后，我已经如此习惯于把不必要的props传递下去并且破坏父组件的封装以至于我在一周之前才意识到我为什么一定要这样做。</p><p><strong>在class组件中，函数属性本身并不是数据流的一部分。</strong>组件的方法中包含了可变的this变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做“diff”。我们无法知道传入的<code>this.props.fetchData</code> 是否依赖状态，并且不知道它依赖的状态是否改变了。</p><p><strong>使用<code>useCallback</code>，函数完全可以参与到数据流中。</strong>我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。感谢周到的<code>useCallback</code>，属性比如<code>props.fetchData</code>的改变也会自动传递下去。</p><p>类似的，<code>useMemo</code>可以让我们对复杂对象做类似的事情。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">function ColorPicker() &#123;<br>  // Doesn&#x27;t break Child&#x27;s shallow equality prop<span class="hljs-built_in"> check</span><br><span class="hljs-built_in"></span>  // unless the color actually changes.<br> <span class="hljs-built_in"> const </span>[color, setColor] = useState(&#x27;pink&#x27;);<br> <span class="hljs-built_in"> const </span>style = useMemo(() =&gt; (&#123; color &#125;), [color]);<br> <span class="hljs-built_in"> return </span>&lt;Child style=&#123;style&#125; /&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我想强调的是，到处使用<code>useCallback</code>是件挺笨拙的事。</strong>当我们需要将函数传递下去并且函数会在子组件的effect中被调用的时候，<code>useCallback</code> 是很好的技巧且非常有用。或者你想试图减少对子组件的记忆负担，也不妨一试。但总的来说Hooks本身能更好地<a href="https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down">避免传递回调函数</a>。</p><p>在上面的例子中，我更倾向于把<code>fetchData</code>放在我的effect里（它可以抽离成一个自定义Hook）或者是从顶层引入。我想让effects保持简单，而在里面调用回调会让事情变得复杂。（“如果某个<code>props.onComplete</code>回调改变了而请求还在进行中会怎么样？”）你可以模拟class的行为但那样并不能解决竞态的问题。</p><h3 id="说说竞态"><a href="#说说竞态" class="headerlink" title="说说竞态"></a>说说竞态</h3><p>下面是一个典型的在class组件里发请求的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<br>    article: <span class="hljs-literal">null</span><br>  &#125;;<br>  componentDidMount() &#123;<br>    <span class="hljs-keyword">this</span>.fetchData(<span class="hljs-keyword">this</span>.props.id);<br>  &#125;<br>  async fetchData(id) &#123;<br>    const article = await <span class="hljs-type">API</span>.fetchArticle(id);<br>    <span class="hljs-keyword">this</span>.setState(&#123; article &#125;);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>你很可能已经知道，上面的代码埋伏了一些问题。它并没有处理更新的情况。所以第二个你能够在网上找到的经典例子是下面这样的：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Article extends Component &#123;<br>  state = &#123;<br>    article: null<br>  &#125;;<br>  component<span class="hljs-constructor">DidMount()</span> &#123;<br>    this.fetch<span class="hljs-constructor">Data(<span class="hljs-params">this</span>.<span class="hljs-params">props</span>.<span class="hljs-params">id</span>)</span>;<br>  &#125;<br>  component<span class="hljs-constructor">DidUpdate(<span class="hljs-params">prevProps</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (prevProps.id !== this.props.id) &#123;<br>      this.fetch<span class="hljs-constructor">Data(<span class="hljs-params">this</span>.<span class="hljs-params">props</span>.<span class="hljs-params">id</span>)</span>;<br>    &#125;<br>  &#125;<br>  async fetch<span class="hljs-constructor">Data(<span class="hljs-params">id</span>)</span> &#123;<br>    const article = await <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">API</span>.</span></span>fetch<span class="hljs-constructor">Article(<span class="hljs-params">id</span>)</span>;<br>    this.set<span class="hljs-constructor">State(&#123; <span class="hljs-params">article</span> &#125;)</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这显然好多了！但依旧有问题。有问题的原因是请求结果返回的顺序不能保证一致。比如我先请求 <code>&#123;id: 10&#125;</code>，然后更新到<code>&#123;id: 20&#125;</code>，但<code>&#123;id: 20&#125;</code>的请求更先返回。请求更早但返回更晚的情况会错误地覆盖状态值。</p><p>这被叫做竞态，这在混合了<code>async / await</code>（假设在等待结果返回）和自顶向下数据流的代码中非常典型（props和state可能会在async函数调用过程中发生改变）。</p><p>Effects并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个<code>async</code> 函数给effect。（我们会改善这个警告来更好地解释你可能会遇到的这些问题。）</p><p>如果你使用的异步方式支持取消，那太棒了。你可以直接在清除函数中取消异步请求。</p><p>或者，最简单的权宜之计是用一个布尔值来跟踪它：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Article(&#123; <span class="hljs-params">id</span> &#125;)</span> &#123;<br>  const <span class="hljs-literal">[<span class="hljs-identifier">article</span>, <span class="hljs-identifier">setArticle</span>]</span> = use<span class="hljs-constructor">State(<span class="hljs-params">null</span>)</span>;<br><br>  use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br>    <span class="hljs-keyword">let</span> didCancel = <span class="hljs-literal">false</span>;<br><br>    async <span class="hljs-keyword">function</span> fetch<span class="hljs-constructor">Data()</span> &#123;<br>      const article = await <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">API</span>.</span></span>fetch<span class="hljs-constructor">Article(<span class="hljs-params">id</span>)</span>;<br>      <span class="hljs-keyword">if</span> (!didCancel) &#123;<br>        set<span class="hljs-constructor">Article(<span class="hljs-params">article</span>)</span>;<br>      &#125;<br>    &#125;<br><br>    fetch<span class="hljs-constructor">Data()</span>;<br><br>    return<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br>      didCancel = <span class="hljs-literal">true</span>;<br>    &#125;;<br>  &#125;, <span class="hljs-literal">[<span class="hljs-identifier">id</span>]</span>);<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.robinwieruch.de/react-hooks-fetch-data/">这篇文章</a>讨论了更多关于如何处理错误和加载状态，以及抽离逻辑到自定义的Hook。我推荐你认真阅读一下如果你想学习更多关于如何在Hooks里请求数据的内容。</p><h3 id="提高水准"><a href="#提高水准" class="headerlink" title="提高水准"></a>提高水准</h3><p>在class组件生命周期的思维模型中，副作用的行为和渲染输出是不同的。UI渲染是被props和state驱动的，并且能确保步调一致，但副作用并不是这样。这是一类常见问题的来源。</p><p>而在<code>useEffect</code>的思维模型中，默认都是同步的。副作用变成了React数据流的一部分。对于每一个<code>useEffect</code>调用，一旦你处理正确，你的组件能够更好地处理边缘情况。</p><p>然而，用好<code>useEffect</code>的前期学习成本更高。这可能让人气恼。用同步的代码去处理边缘情况天然就比触发一次不用和渲染结果步调一致的副作用更难。</p><p>这难免让人担忧如果<code>useEffect</code>是你现在使用最多的工具。不过，目前大抵还处理低水平使用阶段。因为Hooks太新了所以大家都还在低水平地使用它，尤其是在一些教程示例中。但在实践中，社区很可能即将开始高水平地使用Hooks，因为好的API会有更好的动量和冲劲。</p><p>我看到不同的应用在创造他们自己的Hooks，比如封装了应用鉴权逻辑的useFetch或者使用theme context的<code>useTheme</code> 。你一旦有了包含这些的工具箱，你就不会那么频繁地直接使用<code>useEffect</code>。但每一个基于它的Hook都能从它的适应能力中得到益处。</p><p>目前为止，<code>useEffect</code>主要用于数据请求。但是数据请求准确说并不是一个同步问题。因为我们的依赖经常是[]所以这一点尤其明显。那我们究竟在同步什么？</p><p>长远来看， <code>Suspense</code>用于数据请求 会允许第三方库通过第一等的途径告诉React暂停渲染直到某些异步事物（任何东西：代码，数据，图片）已经准备就绪。</p><p>当Suspense逐渐地覆盖到更多的数据请求使用场景，我预料<code>useEffect</code> 会退居幕后作为一个强大的工具，用于同步props和state到某些副作用。不像数据请求，它可以很好地处理这些场景因为它就是为此而设计的。不过在那之前，自定义的Hooks比如<a href="https://www.robinwieruch.de/react-hooks-fetch-data/">这儿提到</a>的是复用数据请求逻辑很好的方式。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用手写代码</title>
    <link href="/2021/11/30/HandwrittenCode/"/>
    <url>/2021/11/30/HandwrittenCode/</url>
    
    <content type="html"><![CDATA[<h2 id="常用手写代码"><a href="#常用手写代码" class="headerlink" title="常用手写代码"></a>常用手写代码</h2><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>维基百科上说道：柯里化，英语：Currying(果然是满满的英译中的既视感)，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><h4 id="Currying有哪些好处呢？"><a href="#Currying有哪些好处呢？" class="headerlink" title="Currying有哪些好处呢？"></a>Currying有哪些好处呢？</h4><ol><li>参数复用</li><li>提前确认</li><li>延迟运行</li></ol><h4 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span><span class="hljs-params">(fn,<span class="hljs-rest_arg">...args</span>)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (args.length &gt;= fn.length) <span class="hljs-keyword">return</span> fn(...args)<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args2</span>)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> curry(fn, ...args, ...args2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>防抖，一段时间内触发一次，再次触发会重置时间 debounce</p><h4 id="手写代码-1"><a href="#手写代码-1" class="headerlink" title="手写代码"></a>手写代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br>        <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.apply(context, args);<br>        &#125;, wait);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>带立即执行需要引入callNow变量</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs maxima">function debounce3(fn, wait) &#123;<br>    <span class="hljs-built_in">let</span> <span class="hljs-built_in">timer</span>;<br>    <span class="hljs-built_in">return</span> function () &#123;<br>        <span class="hljs-built_in">let</span> <span class="hljs-built_in">context</span> = this;<br>        <span class="hljs-built_in">let</span> <span class="hljs-built_in">args</span> = arguments;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">timer</span>) clearTimeout(<span class="hljs-built_in">timer</span>)<br>        <span class="hljs-built_in">let</span> callNow = !<span class="hljs-built_in">timer</span>;<br>        <span class="hljs-built_in">timer</span> = setTimeout(() =&gt; &#123;<br>            <span class="hljs-built_in">timer</span> = null;<br>        &#125;, wait)<br>        callNow &amp;&amp; fn.<span class="hljs-built_in">apply</span>(<span class="hljs-built_in">context</span>, <span class="hljs-built_in">args</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流，一段时间内只触发一次</p><h4 id="手写代码-2"><a href="#手写代码-2" class="headerlink" title="手写代码"></a>手写代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">if</span> (!timer) &#123;<br>            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                fn.apply(context, <span class="hljs-built_in">arguments</span>);<br>                timer = <span class="hljs-literal">null</span>;<br>            &#125;, wait)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="new的实现"><a href="#new的实现" class="headerlink" title="new的实现"></a>new的实现</h3><h4 id="new做了哪些事"><a href="#new做了哪些事" class="headerlink" title="new做了哪些事"></a>new做了哪些事</h4><ol><li>定义一个空对象</li><li><code>Object.setPrototypeOf(obj, fn.prototype)</code> 即 <code>obj.__proto__ = Animal.prototype</code>， 建立了 obj 对象的原型链：<code>obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null</code></li><li>执行构造函数中的代码（为这个新对象添加属性并绑定this）；</li><li>返回新对象 （如果构造函数返回一个对象就会返回构造函数返回的对象）。<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">_new(<span class="hljs-params">fn</span>, <span class="hljs-operator">...</span><span class="hljs-params">args</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>set<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">obj</span>, <span class="hljs-params">fn</span>.<span class="hljs-params">prototype</span>)</span>;<br>    <span class="hljs-keyword">let</span> result = fn.apply(obj, args);<br>    return result instanceof Object ? result : obj;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="解释一下"><a href="#解释一下" class="headerlink" title="解释一下"></a>解释一下</h4><p>我们在实际的项目中，肯定不能让每个对象的值都指向同一个堆内存，这样的话不便于我们做操作，所以自然而然的诞生了深拷贝<br>深拷贝作用在引用类型上！例如：Object，Array<br>深拷贝不会拷贝引用类型的引用，而是将引用类型的值全部拷贝一份，形成一个新的引用类型，这样就不会发生引用错乱的问题，使得我们可以多次使用同样的数据，而不用担心数据之间会起冲突</p><h4 id="递归实现代码"><a href="#递归实现代码" class="headerlink" title="递归实现代码"></a>递归实现代码</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 定义一个深拷贝函数  接收目标target参数</span><br><span class="hljs-function">function <span class="hljs-title">deepClone</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 定义一个变量</span><br>    let result;<br>    <span class="hljs-comment">// 如果当前需要深拷贝的是一个对象的话</span><br>    <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">target</span> === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 如果是一个数组的话</span><br>        <span class="hljs-keyword">if</span> (Array.isArray(<span class="hljs-keyword">target</span>)) &#123;<br>            result = []; <span class="hljs-comment">// 将result赋值为一个数组，并且执行遍历</span><br>            <span class="hljs-keyword">for</span> (let i in <span class="hljs-keyword">target</span>) &#123;<br>                <span class="hljs-comment">// 递归克隆数组中的每一项</span><br>                result.push(deepClone(<span class="hljs-keyword">target</span>[i]))<br>            &#125;<br>            <span class="hljs-comment">// 判断如果当前的值是null的话；直接赋值为null</span><br>        &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(<span class="hljs-keyword">target</span> === <span class="hljs-keyword">null</span>)</span> </span>&#123;<br>            result = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">// 判断如果当前的值是一个RegExp对象的话，直接赋值    </span><br>        &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(<span class="hljs-keyword">target</span>.constructor === RegExp)</span> </span>&#123;<br>            result = <span class="hljs-keyword">target</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则是普通对象，直接for in循环，递归赋值对象的所有值</span><br>            result = &#123;&#125;;<br>            <span class="hljs-keyword">for</span> (let i in <span class="hljs-keyword">target</span>) &#123;<br>                result[i] = deepClone(<span class="hljs-keyword">target</span>[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果不是对象的话，就是基本数据类型，那么直接赋值</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        result = <span class="hljs-keyword">target</span>;<br>    &#125;<br>    <span class="hljs-comment">// 返回最终结果</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="其他实现方式"><a href="#其他实现方式" class="headerlink" title="其他实现方式"></a>其他实现方式</h4><h5 id="JSON-stringify-以及JSON-parse"><a href="#JSON-stringify-以及JSON-parse" class="headerlink" title="JSON.stringify()以及JSON.parse()"></a>JSON.stringify()以及JSON.parse()</h5><p>使用JSON.stringify()以及JSON.parse()它是不可以拷贝 undefined ， function， RegExp 等等类型的</p><h4 id="Object-assign-target-source"><a href="#Object-assign-target-source" class="headerlink" title="Object.assign(target, source)"></a>Object.assign(target, source)</h4><p>一层对象来说是没有任何问题的，但是如果对象的属性对应的是其它的引用类型的话，还是只拷贝了引用，修改的话还是会有问题</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h4 id="解释一下-1"><a href="#解释一下-1" class="headerlink" title="解释一下"></a>解释一下</h4><p>JSONP 是利用script标签没有跨域限制的特性来解决跨域问题实现数据交互的一种方案</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myJsonp</span>(<span class="hljs-params">options</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//判断是否是第一次jsonp请求</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.jsonpNum) &#123;<br>            <span class="hljs-built_in">window</span>.jsonpNum = <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">window</span>.jsonpNum++<br>        &#125;<br><br>        <span class="hljs-keyword">let</span> &#123;<br>            url,<br>            data,<br>            timeout = <span class="hljs-number">5000</span>,<br>            cbkey = <span class="hljs-string">&#x27;callback&#x27;</span>,<br>        &#125; = options<br><br>        <span class="hljs-comment">//保证每次请求接收的方法都不会重复</span><br>        <span class="hljs-keyword">let</span> funName = <span class="hljs-string">&#x27;jsonpReceive&#x27;</span> + <span class="hljs-built_in">window</span>.jsonpNum<br><br>        <span class="hljs-comment">//清除本次jsonp请求产生的一些无用东西</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clear</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">window</span>[funName] = <span class="hljs-literal">null</span><br>            script.parentNode.removeChild(script);<br>            <span class="hljs-built_in">clearTimeout</span>(timer)<br>        &#125;<br><br>        <span class="hljs-comment">//定义jsonp接收函数</span><br>        <span class="hljs-built_in">window</span>[funName] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>            <span class="hljs-comment">//一旦函数执行了，就等于说请求成功了</span><br>            resolve(res)<br>            clear()<br>        &#125;<br><br>        <span class="hljs-comment">//请求超时计时器</span><br>        <span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            reject(<span class="hljs-string">&#x27;超时了&#x27;</span>)<br>            clear()<br>        &#125;, timeout)<br><br>        <span class="hljs-comment">//定义请求的参数</span><br>        <span class="hljs-keyword">let</span> params = <span class="hljs-string">&#x27;&#x27;</span><br><br>        <span class="hljs-comment">//如果有参数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(data).length) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123;<br>                params += <span class="hljs-string">`&amp;<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(data[key])&#125;</span>`</span>;<br>            &#125;<br><br>            params = params.substr(<span class="hljs-number">1</span>)<br>        &#125;<br><br>        <span class="hljs-comment">//拼接最终的请求路径，结尾拼接回调的方法名</span><br>        url = url + <span class="hljs-string">&#x27;?&#x27;</span> + params + <span class="hljs-string">`&amp;<span class="hljs-subst">$&#123;cbkey&#125;</span>=<span class="hljs-subst">$&#123;funName&#125;</span>`</span><br><br>        <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);<br>        script.src = url;<br>        <span class="hljs-built_in">document</span>.body.appendChild(script);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> options = &#123;<br>       <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg&#x27;</span>,<br>       <span class="hljs-attr">cbkey</span>: <span class="hljs-string">&#x27;jsonpCallback&#x27;</span>,<br>       <span class="hljs-attr">data</span>: &#123;<br>           <span class="hljs-attr">g_tk</span>: <span class="hljs-number">1928093487</span>,<br>           <span class="hljs-attr">inCharset</span>: <span class="hljs-string">&#x27;utf-8&#x27;</span>,<br>           <span class="hljs-attr">outCharset</span>: <span class="hljs-string">&#x27;utf-8&#x27;</span>,<br>           <span class="hljs-attr">notice</span>: <span class="hljs-number">0</span>,<br>           <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;jsonp&#x27;</span>,<br>           <span class="hljs-attr">platform</span>: <span class="hljs-string">&#x27;h5&#x27;</span>,<br>           <span class="hljs-attr">uin</span>: <span class="hljs-number">0</span>,<br>           <span class="hljs-attr">needNewCode</span>: <span class="hljs-number">1</span><br>       &#125;,<br>       <span class="hljs-comment">// QQ音乐接口Jsonp字段</span><br>   &#125;<br><br>   myJsonp(options)<br>       .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>           <span class="hljs-built_in">console</span>.log(res);<br>       &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>           <span class="hljs-built_in">console</span>.log(err)<br>       &#125;)<br></code></pre></td></tr></table></figure><h3 id="call-apply"><a href="#call-apply" class="headerlink" title="call,apply"></a>call,apply</h3><h4 id="解释一下-2"><a href="#解释一下-2" class="headerlink" title="解释一下"></a>解释一下</h4><p>call和apply这两个方法的功能是：用来修改函数的执行上下文(this)。<br>call(thisObj,arg1,arg2,arg3,……)<br>A.fn.call(B,”dance”);<br>区别就是参数传递的方式</p><h4 id="手写代码-3"><a href="#手写代码-3" class="headerlink" title="手写代码"></a>手写代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// call模拟</span><br> <span class="hljs-built_in">Function</span>.prototype.call_ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>     <span class="hljs-comment">//判断是否为null或者undefined,同时考虑传递参数不是对象情况</span><br>     obj = obj ? <span class="hljs-built_in">Object</span>(obj) : <span class="hljs-built_in">window</span>;<br>     <span class="hljs-keyword">var</span> args = [];<br>     <span class="hljs-comment">// 注意i从1开始</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) &#123;<br>         args.push(<span class="hljs-string">&quot;arguments[&quot;</span> + i + <span class="hljs-string">&quot;]&quot;</span>);<br>     &#125;;<br>     obj.fn = <span class="hljs-built_in">this</span>; <span class="hljs-comment">// 此时this就是函数fn</span><br>     <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;obj.fn(&quot;</span> + args + <span class="hljs-string">&quot;)&quot;</span>); <span class="hljs-comment">// 执行fn</span><br>     <span class="hljs-keyword">delete</span> obj.fn; <span class="hljs-comment">//删除fn</span><br>     <span class="hljs-keyword">return</span> result;<br> &#125;;<br> <span class="hljs-comment">// apply模拟</span><br> <span class="hljs-built_in">Function</span>.prototype.apply_ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, arr</span>) </span>&#123;<br>     obj = obj ? <span class="hljs-built_in">Object</span>(obj) : <span class="hljs-built_in">window</span>;<br>     obj.fn = <span class="hljs-built_in">this</span>;<br>     <span class="hljs-keyword">var</span> result;<br>     <span class="hljs-keyword">if</span> (!arr) &#123;<br>         result = obj.fn();<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">var</span> args = [];<br>         <span class="hljs-comment">// 注意这里的i从0开始</span><br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>             args.push(<span class="hljs-string">&quot;arr[&quot;</span> + i + <span class="hljs-string">&quot;]&quot;</span>);<br>         &#125;;<br>         result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;obj.fn(&quot;</span> + args + <span class="hljs-string">&quot;)&quot;</span>); <span class="hljs-comment">// 执行fn</span><br>     &#125;;<br>     <span class="hljs-keyword">delete</span> obj.fn; <span class="hljs-comment">//删除fn</span><br>     <span class="hljs-keyword">return</span> result;<br> &#125;;<br><br><br> <span class="hljs-comment">// ES6 call</span><br> <span class="hljs-built_in">Function</span>.prototype.call_ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>     obj = obj ? <span class="hljs-built_in">Object</span>(obj) : <span class="hljs-built_in">window</span>;<br>     obj.fn = <span class="hljs-built_in">this</span>;<br>     <span class="hljs-comment">// 利用拓展运算符直接将arguments转为数组</span><br>     <span class="hljs-keyword">let</span> args = [...arguments].slice(<span class="hljs-number">1</span>);<br>     <span class="hljs-keyword">let</span> result = obj.fn(...args);<br><br>     <span class="hljs-keyword">delete</span> obj.fn<br>     <span class="hljs-keyword">return</span> result;<br> &#125;;<br> <span class="hljs-comment">// ES6 apply</span><br> <span class="hljs-built_in">Function</span>.prototype.apply_ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, arr</span>) </span>&#123;<br>     obj = obj ? <span class="hljs-built_in">Object</span>(obj) : <span class="hljs-built_in">window</span>;<br>     obj.fn = <span class="hljs-built_in">this</span>;<br>     <span class="hljs-keyword">let</span> result;<br>     <span class="hljs-keyword">if</span> (!arr) &#123;<br>         result = obj.fn();<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         result = obj.fn(...arr);<br>     &#125;;<br><br>     <span class="hljs-keyword">delete</span> obj.fn<br>     <span class="hljs-keyword">return</span> result;<br> &#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议相关</title>
    <link href="/2021/11/29/aboutHttp/"/>
    <url>/2021/11/29/aboutHttp/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP协议相关"><a href="#HTTP协议相关" class="headerlink" title="HTTP协议相关"></a>HTTP协议相关</h2><h3 id="HTTP的全称是什么？"><a href="#HTTP的全称是什么？" class="headerlink" title="HTTP的全称是什么？"></a>HTTP的全称是什么？</h3><p>超文本传输协议，<code>HyperText Transfer Protocol</code>，这几个单词可别发走音了。所谓的超文本就是带标记的文本，刚开始的时候是指HTML。现在HTTP协议传输的东西可不只是HTML了，什么表单啊JSON啊XML啊文件啊都可以传输。</p><h3 id="HTTP常用的状态码有哪些？"><a href="#HTTP常用的状态码有哪些？" class="headerlink" title="HTTP常用的状态码有哪些？"></a>HTTP常用的状态码有哪些？</h3><p>400 Bad Request 用于参数验证，少了一个参数或者参数类型错误之类的。<br>502 Bad Gateway 后端服务挂掉或者压力过大的时候， Nginx接到的请求无法及时传递给后端的服务进行处理，这个时候就会出现502错误。这个也非常常见，知乎豆瓣网站经常开小差的时候发生的错误就是这个。<br>304 Not Modified 极少人知道这个状态码，因为大部分后端开发者的前端Javascript开发经验都严重不足。当你用Chrome打开一个经常访问的网站，看看Network传输的静态资源就可以看到很多304状态码。它表示该资源被浏览器缓存了不需要重新请求服务器。<br>401 Unauthorized 权限不足，这个很好理解，就是资源存在但是不让你访问。<br>403 Forbidden 资源禁止访问，如果你的IP列为黑名单了，就会发生这种错误。<br>其实还有很多状态码，小编也没去好好研究了，因为实在不会在工作中用到。感兴趣的请继续阅读维基百科</p><h3 id="HTTP有哪些Method？"><a href="#HTTP有哪些Method？" class="headerlink" title="HTTP有哪些Method？"></a>HTTP有哪些Method？</h3><p>GET 不解释，如果读者不知道，建议别在IT圈混了。<br>POST 一般用于创建或者修改资源，在RESTFUL规范里面POST只用来创建资源，并返回201 Created状态码表示创建成功。不过大多数网站都不遵循严格的RESTFUL规范，POST拿来做修改资源的事也是非常常见的。<br>PUT 对应于POST表示创建资源，PUT用于修改资源，PUT的参数必须是对象的全部属性，修改是覆盖式全部修改。<br>PATCH 对应于PUT的参数是对象的全部属性，PATCH的参数是部分属性，修改是局部字段修改。<br>DELETE 用于删除资源。<br>HEAD 不常用，跟GET差不多，区别就是不返回Body内容，只返回HTTP头信息。一般用于获取资源的元信息，比如长度，修改时间等<br>OPTIONS 跨域相关，后面再讲。</p><h3 id="HTTP协议格式是怎样的？"><a href="#HTTP协议格式是怎样的？" class="headerlink" title="HTTP协议格式是怎样的？"></a>HTTP协议格式是怎样的？</h3><p>HTTP的请求和响应的消息协议是一样的，分为三个部分，起始行、消息头和消息体。这三个部分以CRLF作为分隔符。最后一个消息头有两个CRLF，用来表示消息头部的结束。<br><img src="https://s3.bmp.ovh/imgs/2021/11/9edd247283374236.png" alt="alt HTTP协议格式"></p><p>HTTP请求的起始行称为请求行，形如GET /index.html HTTP/1.1<br>HTTP响应的起始行称为状态行，形如200 ok<br>消息头部有很多键值对组成，多个键值对之间使用CRLF作为分隔符，也可以完全没有键值对。形如Content-Encoding: gzip<br>消息体是一个字符串，字符串的长度是由消息头部的Content-Length键指定的。如果没有Content-Length字段说明没有消息体，譬如GET请求就是没有消息体的，POST请求的消息体一般用来放置表单数据。GET请求的响应返回的页面内容也是放在消息体里面的。我们平时调用API返回的JSON内容都是放在消息体里面的。</p><h3 id="什么是分块传送？"><a href="#什么是分块传送？" class="headerlink" title="什么是分块传送？"></a>什么是分块传送？</h3><p>当浏览器向服务器请求一个资源时，这个资源是一个动态资源，服务器无法提前预知资源的大小，这个时候就可以使用分块传输。<br>服务器先生成一个thunk，发送这个chunk，再生成一个chunk，再发送一个chunk，直到全部资源传送完成。<br>分块传送需要在请求头增加一个特殊的键值对transfer-encoding: thunked，那么消息体的内容便是分块传送的。<br><img src="https://s3.bmp.ovh/imgs/2021/11/f08205bdbf44c61d.png" alt="alt 分块传送"><br>chunked传输格式如图所示，由一段一段的分块组合而成，每个块由一个长度行和一个分块体组成，最后一个分块长度为0表示结束。</p><h3 id="持久连接的机制是怎样的？"><a href="#持久连接的机制是怎样的？" class="headerlink" title="持久连接的机制是怎样的？"></a>持久连接的机制是怎样的？</h3><p>HTTP早期版本中每个请求都会发起一个连接，一个网页除了页面的HTML之外还会有很多静态资源以及诸多的API调用，如果每个请求都一个连接，势必网页的一次加载就会和服务器创建多次连接，这是非常浪费服务器资源的，同时也让客户端的访问速度慢了不少。HTTP1.0之后引入了Keep-Alive持久连接，在HTTP1.1版本中成为默认选项。它使得HTTP的一个连接可以连续服务多个请求，有效节省了资源，增加了客户端页面的加载速度。<br>持久连接也不宜一直保持，毕竟每个连接都会占用服务器资源，如果打开网页的人太多，那服务器资源也会紧张，所以一般服务器都会配置一个KeepAlive Timeout参数和KeepAlive Requests参数限制单个连接持续时长和最多服务的请求次数。<br>如果服务器设置的timeout时长为0，就退化到非持久连接。非持久连接会在响应头部增加一个头信息Connection: Close通知客户端在接受完当前响应后连接需要立即关闭。<br>同样浏览器也不会因为服务器将KeepAlive Timeout配置了无限长就不管不问一直持续保持连接。每个浏览器都有它自己的内置限制，具体限制浏览器厂商各有不同。</p><h3 id="如何理解HTTP协议的无状态性？"><a href="#如何理解HTTP协议的无状态性？" class="headerlink" title="如何理解HTTP协议的无状态性？"></a>如何理解HTTP协议的无状态性？</h3><p>所谓HTTP协议的无状态性是指服务器的协议层无需为不同的请求之间建立任何相关关系，它特指的是协议层的无状态性。但是这并不代表建立在HTTP协议之上的应用程序就无法维持状态。应用层可以通过会话Session来跟踪用户请求之间的相关性，服务器会为每个会话对象绑定一个唯一的会话ID，浏览器可以将会话ID记录在本地缓存LocalStorage或者Cookie，在后续的请求都带上这个会话ID，服务器就可以为每个请求找到相应的会话状态。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS中的层叠上下文和层叠顺序</title>
    <link href="/2021/11/26/stacking-context/"/>
    <url>/2021/11/26/stacking-context/</url>
    
    <content type="html"><![CDATA[<h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><h3 id="一、什么是层叠上下文"><a href="#一、什么是层叠上下文" class="headerlink" title="一、什么是层叠上下文"></a>一、什么是层叠上下文</h3><p>层叠上下文，英文称作”stacking context”. 是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。</p><p>这里出现了一个名词-z轴，指的是什么呢？</p><p>表示的是用户与屏幕的这条看不见的垂直线。</p><p>层叠上下文是一个概念，跟「块状格式化上下文(BFC)」类似。然而，概念这个东西是比较虚比较抽象的，要想轻松理解，我们需要将其具象化。</p><p>怎么个具象化法呢？</p><p>你可以把「层叠上下文」理解为当官：网页中有很多很多的元素，我们可以看成是真实世界的芸芸众生。真实世界里，我们大多数人是普通老百姓们，还有一部分人是做官的官员。OK，这里的“官员”就可以理解为网页中的层叠上下文元素。</p><p>换句话说，页面中的元素有了层叠上下文，就好比我们普通老百姓当了官，一旦当了官，相比普通老百姓而言，离皇帝更近了，对不对，就等同于网页中元素级别更高，离我们用户更近了。</p><h3 id="二、什么是层叠水平"><a href="#二、什么是层叠水平" class="headerlink" title="二、什么是层叠水平"></a>二、什么是层叠水平</h3><p>再来说说层叠水平。“层叠水平”英文称作”stacking level”，决定了同一个层叠上下文中元素在z轴上的显示顺序。level这个词很容易让我们联想到我们真正世界中的三六九等、论资排辈。真实世界中，每个人都是独立的个体，包括同卵双胞胎，有差异就有区分。例如，双胞胎虽然长得像Ctrl+C/Ctrl+V得到的，但实际上，出生时间还是有先后顺序的，先出生的那个就大，大哥或大姐。网页中的元素也是如此，页面中的每个元素都是独立的个体，他们一定是会有一个类似的排名排序的情况存在。而这个排名排序、论资排辈就是我们这里所说的“层叠水平”。层叠上下文元素的层叠水平可以理解为官员的职级，1品2品，县长省长之类；对于普通元素，这个嘛……你自己随意理解。</p><p>于是，显而易见，所有的元素都有层叠水平，包括层叠上下文元素，层叠上下文元素的层叠水平可以理解为官员的职级，1品2品，县长省长之类。然后，对于普通元素的层叠水平，我们的探讨仅仅局限在当前层叠上下文元素中。为什么呢？因为否则没有意义。</p><p>这么理解吧~ 上面提过元素具有层叠上下文好比当官，大家都知道的，这当官的家里都有丫鬟啊保镖啊管家啊什么的。所谓打狗看主人，A官员家里的管家和B官员家里的管家做PK实际上是没有意义的，因为他们牛不牛逼完全由他们的主子决定的。一人得道鸡犬升天，你说这和珅家里的管家和七侠镇娄知县县令家里的管家有可比性吗？李总理的秘书是不是分分钟灭了你村支部书记的秘书（如果有）。</p><p>翻译成术语就是：普通元素的层叠水平优先由层叠上下文决定，因此，层叠水平的比较只有在当前层叠上下文元素中才有意义。</p><p>需要注意的是，诸位千万不要把层叠水平和CSS的z-index属性混为一谈。没错，某些情况下z-index确实可以影响层叠水平，但是，只限于定位元素以及flex盒子的孩子元素；而层叠水平所有的元素都存在。</p><h3 id="三、什么是层叠顺序"><a href="#三、什么是层叠顺序" class="headerlink" title="三、什么是层叠顺序"></a>三、什么是层叠顺序</h3><p>再来说说层叠顺序。“层叠顺序”英文称作”stacking order”. 表示元素发生层叠时候有着特定的垂直显示顺序，注意，这里跟上面两个不一样，上面的层叠上下文和层叠水平是概念，而这里的层叠顺序是规则。</p><p>在CSS2.1的年代，在CSS3还没有出现的时候（注意这里的前提），层叠顺序规则遵循下面这张图：<br><img src="https://s3.bmp.ovh/imgs/2021/11/bdb573ccb36a3195.png" alt="alt 层叠顺序规则"><br>有人可能有见过类似图，那个图是很多很多年前老外绘制的，英文内容。而是更关键的是国内估计没有同行进行过验证与实践，实际上很多关键信息缺失。</p><p>缺失的关键信息包括：</p><ol><li>第一项 位于最低水平的 <kbd>border/background</kbd>指的是层叠上下文元素的边框和背景色。每一个层叠顺序规则适用于一个完整的层叠上下文元素。</li><li>原图没有呈现inline-block的层叠顺序，实际上，inline-block和inline水平元素是同等level级别。</li><li>z-index:0实际上和z-index:auto单纯从层叠水平上看，是可以看成是一样的。注意这里的措辞——“单纯从层叠水平上看”，实际上，两者在层叠上下文领域有着根本性的差异。<br>下面我要向大家发问了，大家有没有想过，为什么内联元素的层叠顺序要比浮动元素和块状元素都高？</li></ol><p>为什么呢？我明明感觉浮动元素和块状元素要更屌一点啊。</p><p>嘿嘿嘿，我就不卖关子了，直接看下图的标注说明：<br><img src="https://s3.bmp.ovh/imgs/2021/11/c2e53ebce4211353.png" alt="alt 层叠顺序规则"></p><p>诸如border/background一般为装饰属性，而浮动和块状元素一般用作布局，而内联元素都是内容。网页中最重要的是什么？当然是内容了哈，对不对！</p><p>因此，一定要让内容的层叠顺序相当高，当发生层叠是很好，重要的文字啊图片内容可以优先暴露在屏幕上。</p><h3 id="四、务必牢记的层叠准则"><a href="#四、务必牢记的层叠准则" class="headerlink" title="四、务必牢记的层叠准则"></a>四、务必牢记的层叠准则</h3><p>下面这两个是层叠领域的黄金准则。当元素发生层叠的时候，其覆盖关系遵循下面2个准则：</p><ol><li><b>谁大谁上：</b> 当具有明显的层叠水平标示的时候，如识别的z-indx值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。通俗讲就是官大的压死官小的。</li><li><b>后来居上：</b>当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</li></ol><p>在CSS和HTML领域，只要元素发生了重叠，都离不开上面这两个黄金准则。因为后面会有多个实例说明，这里就到此为止。</p><h3 id="五、层叠上下文的特性"><a href="#五、层叠上下文的特性" class="headerlink" title="五、层叠上下文的特性"></a>五、层叠上下文的特性</h3><p>层叠上下文元素有如下特性：</p><ul><li>层叠上下文的层叠水平要比普通元素高</li><li>层叠上下文可以阻断元素的混合模式</li><li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。</li><li>每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。</li><li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li></ul><h3 id="六、层叠上下文的创建"><a href="#六、层叠上下文的创建" class="headerlink" title="六、层叠上下文的创建"></a>六、层叠上下文的创建</h3><p>卖了这么多文字，到底层叠上下文是个什么鬼，倒是拿出来瞅瞅啊！</p><p>哈哈。如同块状格式化上下文，层叠上下文也基本上是有一些特定的CSS属性创建的。我将其总结为3个流派，也就是做官的3种途径：</p><ol><li>皇亲国戚派：页面根元素天生具有层叠上下文，称之为“根层叠上下文”。</li><li>科考入选派：z-index值为数值的定位元素的传统层叠上下文。</li><li>其他当官途径：其他CSS3属性。</li></ol><h4 id="1-根层叠上下文"><a href="#1-根层叠上下文" class="headerlink" title="1. 根层叠上下文"></a>1. 根层叠上下文</h4><p>指的是页面根元素，也就是滚动条的默认的始作俑者<code>&lt;html&gt;</code>元素。这就是为什么，绝对定位元素在<code>left/top</code>等值定位的时候，如果没有其他定位元素限制，会相对浏览器窗口定位的原因。</p><h4 id="2-定位元素与传统层叠上下文"><a href="#2-定位元素与传统层叠上下文" class="headerlink" title="2. 定位元素与传统层叠上下文"></a>2. 定位元素与传统层叠上下文</h4><p>对于包含有<code>position:relative/position:absolute</code>的定位元素，以及FireFox/IE浏览器（不包括Chrome等webkit内核浏览器）（目前，也就是2016年初是这样）下含有<code>position:fixed</code>声明的定位元素，当其<code>z-index</code>值不是<code>auto</code>的时候，会创建层叠上下文。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;position:relative; z-index:auto;&quot;</span>&gt;<br>    &lt;img src=<span class="hljs-string">&quot;mm1.jpg&quot;</span> style=<span class="hljs-string">&quot;position:absolute; z-index:2;&quot;</span>&gt;    &lt;<span class="hljs-comment">-- 横妹子 --&gt;</span><br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;position:relative; z-index:auto;&quot;</span>&gt;<br>    &lt;img src=<span class="hljs-string">&quot;mm2.jpg&quot;</span> style=<span class="hljs-string">&quot;position:relative; z-index:1;&quot;</span>&gt;    &lt;<span class="hljs-comment">-- 竖妹子 --&gt;</span><br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2021/11/cd1fe1668945295e.png" alt="alt 层叠顺序规则"></p><p>大家会发现，竖着的妹子(mm2)被横着的妹子(mm1)给覆盖了。</p><p>下面，我们对父级简单调整下，把z-index:auto改成层叠水平一致的z-index:0, 代码如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;position:relative; z-index:0;&quot;</span>&gt;<br>    &lt;img src=<span class="hljs-string">&quot;mm1.jpg&quot;</span> style=<span class="hljs-string">&quot;position:absolute; z-index:2;&quot;</span>&gt;    &lt;<span class="hljs-comment">-- 横妹子 --&gt;</span><br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;position:relative; z-index:0;&quot;</span>&gt;<br>    &lt;img src=<span class="hljs-string">&quot;mm2.jpg&quot;</span> style=<span class="hljs-string">&quot;position:relative; z-index:1;&quot;</span>&gt;    &lt;<span class="hljs-comment">-- 竖妹子 --&gt;</span><br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2021/11/212b18d02d746cc4.png" alt="alt 层叠顺序规则"></p><p>为什么小小的改变会有想法的结果呢？</p><p>差别就在于，<code>z-index:0</code>所在的<code>&lt;div&gt;</code>元素是层叠上下文元素，而<code>z-index:auto</code>所在的<code>&lt;div&gt;</code>元素是一个普通的元素，于是，里面的两个<code>&lt;img&gt;</code>妹子的层叠比较就不受父级的影响，两者直接套用层叠黄金准则，这里，两者有着明显不一的<code>z-index</code>值，因此，遵循<b>“谁大谁上”</b>的准则，于是，<code>z-index</code>为<code>2</code>的那个横妹子，就趴在了<code>z-index</code>为<code>1</code>的竖妹子身上。</p><p>而<code>z-index</code>一旦变成数值，哪怕是<code>0</code>，都会创建一个层叠上下文。此时，层叠规则就发生了变化。层叠上下文的特性里面最后一条——自成体系。两个<code>&lt;img&gt;</code>妹子的层叠顺序比较变成了优先比较其父级层叠上下文元素的层叠顺序。这里，由于两者都是<code>z-index:0</code>，层叠顺序这一块两者一样大，此时，遵循层叠黄金准则的另外一个准则<b>“后来居上”</b>，根据在DOM流中的位置决定谁在上面，于是，位于后面的竖着的妹子就自然而然趴在了横着的妹子身上。对，没错，<code>&lt;img&gt;</code>元素上的<code>z-index</code>打酱油了！</p><p>有时候，我们在网页重构的时候，会发现，<code>z-index</code>嵌套错乱，看看是不是受父级的层叠上下文元素干扰了。然后，可能没多大意义了，但我还是提一下，算是祭奠下，IE6/IE7浏览器有个bug，就是<code>z-index:auto</code>的定位元素也会创建层叠上下文。这就是为什么在过去，IE6/IE7的<code>z-index</code>会搞死人的原因。</p><p>然后，我再提一下<code>position:fixed</code>, 在过去，<code>position:fixed</code>和<code>relative/absolute</code>在层叠上下文这一块是一路货色，都是需要<code>z-index</code>为数值才行。但是，不知道什么时候起，Chrome等webkit内核浏览器，<code>position:fixed</code>元素天然层叠上下文元素，无需<code>z-index</code>为数值。根据我的测试，目前，IE以及FireFox仍是老套路。</p><h4 id="3-CSS3与新时代的层叠上下文"><a href="#3-CSS3与新时代的层叠上下文" class="headerlink" title="3. CSS3与新时代的层叠上下文"></a>3. CSS3与新时代的层叠上下文</h4><p>CSS3的出现除了带来了新属性，同时还对过去的很多规则发出了挑战。例如，CSS3 <code>transform</code>对<code>overflow</code>隐藏对<code>position:fixed</code>定位的影响等。而这里，层叠上下文这一块的影响要更加广泛与显著。</p><p>如下：</p><ol><li><code>z-index</code>值不为<code>auto</code>的<code>flex</code>项(父元素<code>display:flex|inline-flex</code>).</li><li>元素的<code>opacity</code>值不是<code>1</code>.</li><li>元素的<code>transform</code>值不是<code>none</code>.</li><li>元素<code>mix-blend-mode</code>值不是<code>normal</code>.</li><li>元素的<code>filter</code>值不是<code>none</code>.</li><li>元素的<code>isolation</code>值是<code>isolate</code>.</li><li><code>will-change</code>指定的属性值为上面任意一个。</li><li>元素的<code>-webkit-overflow-scrolling</code>设为<code>touch</code>.</li></ol><h3 id="七、结束语"><a href="#七、结束语" class="headerlink" title="七、结束语"></a>七、结束语</h3><p>只要元素发生层叠，要解释其表现，基本上就本文的这些内容了。</p><p>我发现很多重构小伙伴都有<code>z-index</code>滥用，或者使用不规范的问题。我觉得最主要的原因还是对理解层叠上下文以及层叠顺序这些概念都不了解。例如，只要使用了定位元素，尤其<code>absolute</code>绝对定位，都离不开设置一个<code>z-index</code>值；或者只要元素被其他元素覆盖了，例如变成定位元素或者增加<code>z-index</code>值升级。页面一复杂，必然搞得乱七八糟。</p><p>实际上，在我看来，觉得多数常见，<code>z-index</code>根本就没有出现的必要。知道了内联元素的层叠水平比块状元素高，于是，某条线你想覆盖上去的时候，需要设置<code>position:relative</code>吗？不需要，<code>inline-block</code>化就可以。因为IE6/IE7 <code>position:relative</code>会创建层叠上下文，很烦的。</p><p>OK，本文已经够长了，就不多啰嗦了。</p><p>行为匆忙，出错在所难免，欢迎大力指正。也欢迎各种形式的交流，或者指出文中概念性的错误。</p><p>感谢阅读！</p><p><a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/">参考地址</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/11/26/hello-world/"/>
    <url>/2021/11/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

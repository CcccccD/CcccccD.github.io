<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常用手写代码</title>
    <link href="/2021/11/30/HandwrittenCode/"/>
    <url>/2021/11/30/HandwrittenCode/</url>
    
    <content type="html"><![CDATA[<h2 id="常用手写代码"><a href="#常用手写代码" class="headerlink" title="常用手写代码"></a>常用手写代码</h2><h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>维基百科上说道：柯里化，英语：Currying(果然是满满的英译中的既视感)，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><h4 id="Currying有哪些好处呢？"><a href="#Currying有哪些好处呢？" class="headerlink" title="Currying有哪些好处呢？"></a>Currying有哪些好处呢？</h4><ol><li>参数复用</li><li>提前确认</li><li>延迟运行</li></ol><h4 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span><span class="hljs-params">(fn,<span class="hljs-rest_arg">...args</span>)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (args.length &gt;= fn.length) <span class="hljs-keyword">return</span> fn(...args)<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args2</span>)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> curry(fn, ...args, ...args2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>防抖，一段时间内触发一次，再次触发会重置时间 debounce</p><h4 id="手写代码-1"><a href="#手写代码-1" class="headerlink" title="手写代码"></a>手写代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span>;<br>        <span class="hljs-keyword">if</span> (timer) <span class="hljs-built_in">clearTimeout</span>(timer);;<br>        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            fn.apply(context, args);<br>        &#125;, wait);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>带立即执行需要引入callNow变量</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs maxima">function debounce3(fn, wait) &#123;<br>    <span class="hljs-built_in">let</span> <span class="hljs-built_in">timer</span>;<br>    <span class="hljs-built_in">return</span> function () &#123;<br>        <span class="hljs-built_in">let</span> <span class="hljs-built_in">context</span> = this;<br>        <span class="hljs-built_in">let</span> <span class="hljs-built_in">args</span> = arguments;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">timer</span>) clearTimeout(<span class="hljs-built_in">timer</span>)<br>        <span class="hljs-built_in">let</span> callNow = !<span class="hljs-built_in">timer</span>;<br>        <span class="hljs-built_in">timer</span> = setTimeout(() =&gt; &#123;<br>            <span class="hljs-built_in">timer</span> = null;<br>        &#125;, wait)<br>        callNow &amp;&amp; fn.<span class="hljs-built_in">apply</span>(<span class="hljs-built_in">context</span>, <span class="hljs-built_in">args</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>节流，一段时间内只触发一次</p><h4 id="手写代码-2"><a href="#手写代码-2" class="headerlink" title="手写代码"></a>手写代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">if</span> (!timer) &#123;<br>            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                fn.apply(context, <span class="hljs-built_in">arguments</span>);<br>                timer = <span class="hljs-literal">null</span>;<br>            &#125;, wait)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="new的实现"><a href="#new的实现" class="headerlink" title="new的实现"></a>new的实现</h3><h4 id="new做了哪些事"><a href="#new做了哪些事" class="headerlink" title="new做了哪些事"></a>new做了哪些事</h4><ol><li>定义一个空对象</li><li><code>Object.setPrototypeOf(obj, fn.prototype)</code> 即 <code>obj.__proto__ = Animal.prototype</code>， 建立了 obj 对象的原型链：<code>obj-&gt;Animal.prototype-&gt;Object.prototype-&gt;null</code></li><li>执行构造函数中的代码（为这个新对象添加属性并绑定this）；</li><li>返回新对象 （如果构造函数返回一个对象就会返回构造函数返回的对象）。<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">_new(<span class="hljs-params">fn</span>, <span class="hljs-operator">...</span><span class="hljs-params">args</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> obj = &#123;&#125;;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>set<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">obj</span>, <span class="hljs-params">fn</span>.<span class="hljs-params">prototype</span>)</span>;<br>    <span class="hljs-keyword">let</span> result = fn.apply(obj, args);<br>    return result instanceof Object ? result : obj;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="解释一下"><a href="#解释一下" class="headerlink" title="解释一下"></a>解释一下</h4><p>我们在实际的项目中，肯定不能让每个对象的值都指向同一个堆内存，这样的话不便于我们做操作，所以自然而然的诞生了深拷贝<br>深拷贝作用在引用类型上！例如：Object，Array<br>深拷贝不会拷贝引用类型的引用，而是将引用类型的值全部拷贝一份，形成一个新的引用类型，这样就不会发生引用错乱的问题，使得我们可以多次使用同样的数据，而不用担心数据之间会起冲突</p><h4 id="递归实现代码"><a href="#递归实现代码" class="headerlink" title="递归实现代码"></a>递归实现代码</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 定义一个深拷贝函数  接收目标target参数</span><br><span class="hljs-function">function <span class="hljs-title">deepClone</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 定义一个变量</span><br>    let result;<br>    <span class="hljs-comment">// 如果当前需要深拷贝的是一个对象的话</span><br>    <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">target</span> === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 如果是一个数组的话</span><br>        <span class="hljs-keyword">if</span> (Array.isArray(<span class="hljs-keyword">target</span>)) &#123;<br>            result = []; <span class="hljs-comment">// 将result赋值为一个数组，并且执行遍历</span><br>            <span class="hljs-keyword">for</span> (let i in <span class="hljs-keyword">target</span>) &#123;<br>                <span class="hljs-comment">// 递归克隆数组中的每一项</span><br>                result.push(deepClone(<span class="hljs-keyword">target</span>[i]))<br>            &#125;<br>            <span class="hljs-comment">// 判断如果当前的值是null的话；直接赋值为null</span><br>        &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(<span class="hljs-keyword">target</span> === <span class="hljs-keyword">null</span>)</span> </span>&#123;<br>            result = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">// 判断如果当前的值是一个RegExp对象的话，直接赋值    </span><br>        &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(<span class="hljs-keyword">target</span>.constructor === RegExp)</span> </span>&#123;<br>            result = <span class="hljs-keyword">target</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则是普通对象，直接for in循环，递归赋值对象的所有值</span><br>            result = &#123;&#125;;<br>            <span class="hljs-keyword">for</span> (let i in <span class="hljs-keyword">target</span>) &#123;<br>                result[i] = deepClone(<span class="hljs-keyword">target</span>[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果不是对象的话，就是基本数据类型，那么直接赋值</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        result = <span class="hljs-keyword">target</span>;<br>    &#125;<br>    <span class="hljs-comment">// 返回最终结果</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="其他实现方式"><a href="#其他实现方式" class="headerlink" title="其他实现方式"></a>其他实现方式</h4><h5 id="JSON-stringify-以及JSON-parse"><a href="#JSON-stringify-以及JSON-parse" class="headerlink" title="JSON.stringify()以及JSON.parse()"></a>JSON.stringify()以及JSON.parse()</h5><p>使用JSON.stringify()以及JSON.parse()它是不可以拷贝 undefined ， function， RegExp 等等类型的</p><h4 id="Object-assign-target-source"><a href="#Object-assign-target-source" class="headerlink" title="Object.assign(target, source)"></a>Object.assign(target, source)</h4><p>一层对象来说是没有任何问题的，但是如果对象的属性对应的是其它的引用类型的话，还是只拷贝了引用，修改的话还是会有问题</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><h4 id="解释一下-1"><a href="#解释一下-1" class="headerlink" title="解释一下"></a>解释一下</h4><p>JSONP 是利用script标签没有跨域限制的特性来解决跨域问题实现数据交互的一种方案</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myJsonp</span>(<span class="hljs-params">options</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//判断是否是第一次jsonp请求</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">window</span>.jsonpNum) &#123;<br>            <span class="hljs-built_in">window</span>.jsonpNum = <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">window</span>.jsonpNum++<br>        &#125;<br><br>        <span class="hljs-keyword">let</span> &#123;<br>            url,<br>            data,<br>            timeout = <span class="hljs-number">5000</span>,<br>            cbkey = <span class="hljs-string">&#x27;callback&#x27;</span>,<br>        &#125; = options<br><br>        <span class="hljs-comment">//保证每次请求接收的方法都不会重复</span><br>        <span class="hljs-keyword">let</span> funName = <span class="hljs-string">&#x27;jsonpReceive&#x27;</span> + <span class="hljs-built_in">window</span>.jsonpNum<br><br>        <span class="hljs-comment">//清除本次jsonp请求产生的一些无用东西</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clear</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">window</span>[funName] = <span class="hljs-literal">null</span><br>            script.parentNode.removeChild(script);<br>            <span class="hljs-built_in">clearTimeout</span>(timer)<br>        &#125;<br><br>        <span class="hljs-comment">//定义jsonp接收函数</span><br>        <span class="hljs-built_in">window</span>[funName] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>            <span class="hljs-comment">//一旦函数执行了，就等于说请求成功了</span><br>            resolve(res)<br>            clear()<br>        &#125;<br><br>        <span class="hljs-comment">//请求超时计时器</span><br>        <span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            reject(<span class="hljs-string">&#x27;超时了&#x27;</span>)<br>            clear()<br>        &#125;, timeout)<br><br>        <span class="hljs-comment">//定义请求的参数</span><br>        <span class="hljs-keyword">let</span> params = <span class="hljs-string">&#x27;&#x27;</span><br><br>        <span class="hljs-comment">//如果有参数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(data).length) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> data) &#123;<br>                params += <span class="hljs-string">`&amp;<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(data[key])&#125;</span>`</span>;<br>            &#125;<br><br>            params = params.substr(<span class="hljs-number">1</span>)<br>        &#125;<br><br>        <span class="hljs-comment">//拼接最终的请求路径，结尾拼接回调的方法名</span><br>        url = url + <span class="hljs-string">&#x27;?&#x27;</span> + params + <span class="hljs-string">`&amp;<span class="hljs-subst">$&#123;cbkey&#125;</span>=<span class="hljs-subst">$&#123;funName&#125;</span>`</span><br><br>        <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);<br>        script.src = url;<br>        <span class="hljs-built_in">document</span>.body.appendChild(script);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> options = &#123;<br>       <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg&#x27;</span>,<br>       <span class="hljs-attr">cbkey</span>: <span class="hljs-string">&#x27;jsonpCallback&#x27;</span>,<br>       <span class="hljs-attr">data</span>: &#123;<br>           <span class="hljs-attr">g_tk</span>: <span class="hljs-number">1928093487</span>,<br>           <span class="hljs-attr">inCharset</span>: <span class="hljs-string">&#x27;utf-8&#x27;</span>,<br>           <span class="hljs-attr">outCharset</span>: <span class="hljs-string">&#x27;utf-8&#x27;</span>,<br>           <span class="hljs-attr">notice</span>: <span class="hljs-number">0</span>,<br>           <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;jsonp&#x27;</span>,<br>           <span class="hljs-attr">platform</span>: <span class="hljs-string">&#x27;h5&#x27;</span>,<br>           <span class="hljs-attr">uin</span>: <span class="hljs-number">0</span>,<br>           <span class="hljs-attr">needNewCode</span>: <span class="hljs-number">1</span><br>       &#125;,<br>       <span class="hljs-comment">// QQ音乐接口Jsonp字段</span><br>   &#125;<br><br>   myJsonp(options)<br>       .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>           <span class="hljs-built_in">console</span>.log(res);<br>       &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>           <span class="hljs-built_in">console</span>.log(err)<br>       &#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议相关</title>
    <link href="/2021/11/29/aboutHttp/"/>
    <url>/2021/11/29/aboutHttp/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP协议相关"><a href="#HTTP协议相关" class="headerlink" title="HTTP协议相关"></a>HTTP协议相关</h2><h3 id="HTTP的全称是什么？"><a href="#HTTP的全称是什么？" class="headerlink" title="HTTP的全称是什么？"></a>HTTP的全称是什么？</h3><p>超文本传输协议，<code>HyperText Transfer Protocol</code>，这几个单词可别发走音了。所谓的超文本就是带标记的文本，刚开始的时候是指HTML。现在HTTP协议传输的东西可不只是HTML了，什么表单啊JSON啊XML啊文件啊都可以传输。</p><h3 id="HTTP常用的状态码有哪些？"><a href="#HTTP常用的状态码有哪些？" class="headerlink" title="HTTP常用的状态码有哪些？"></a>HTTP常用的状态码有哪些？</h3><p>400 Bad Request 用于参数验证，少了一个参数或者参数类型错误之类的。<br>502 Bad Gateway 后端服务挂掉或者压力过大的时候， Nginx接到的请求无法及时传递给后端的服务进行处理，这个时候就会出现502错误。这个也非常常见，知乎豆瓣网站经常开小差的时候发生的错误就是这个。<br>304 Not Modified 极少人知道这个状态码，因为大部分后端开发者的前端Javascript开发经验都严重不足。当你用Chrome打开一个经常访问的网站，看看Network传输的静态资源就可以看到很多304状态码。它表示该资源被浏览器缓存了不需要重新请求服务器。<br>401 Unauthorized 权限不足，这个很好理解，就是资源存在但是不让你访问。<br>403 Forbidden 资源禁止访问，如果你的IP列为黑名单了，就会发生这种错误。<br>其实还有很多状态码，小编也没去好好研究了，因为实在不会在工作中用到。感兴趣的请继续阅读维基百科</p><h3 id="HTTP有哪些Method？"><a href="#HTTP有哪些Method？" class="headerlink" title="HTTP有哪些Method？"></a>HTTP有哪些Method？</h3><p>GET 不解释，如果读者不知道，建议别在IT圈混了。<br>POST 一般用于创建或者修改资源，在RESTFUL规范里面POST只用来创建资源，并返回201 Created状态码表示创建成功。不过大多数网站都不遵循严格的RESTFUL规范，POST拿来做修改资源的事也是非常常见的。<br>PUT 对应于POST表示创建资源，PUT用于修改资源，PUT的参数必须是对象的全部属性，修改是覆盖式全部修改。<br>PATCH 对应于PUT的参数是对象的全部属性，PATCH的参数是部分属性，修改是局部字段修改。<br>DELETE 用于删除资源。<br>HEAD 不常用，跟GET差不多，区别就是不返回Body内容，只返回HTTP头信息。一般用于获取资源的元信息，比如长度，修改时间等<br>OPTIONS 跨域相关，后面再讲。</p><h3 id="HTTP协议格式是怎样的？"><a href="#HTTP协议格式是怎样的？" class="headerlink" title="HTTP协议格式是怎样的？"></a>HTTP协议格式是怎样的？</h3><p>HTTP的请求和响应的消息协议是一样的，分为三个部分，起始行、消息头和消息体。这三个部分以CRLF作为分隔符。最后一个消息头有两个CRLF，用来表示消息头部的结束。<br><img src="https://s3.bmp.ovh/imgs/2021/11/9edd247283374236.png" alt="alt HTTP协议格式"></p><p>HTTP请求的起始行称为请求行，形如GET /index.html HTTP/1.1<br>HTTP响应的起始行称为状态行，形如200 ok<br>消息头部有很多键值对组成，多个键值对之间使用CRLF作为分隔符，也可以完全没有键值对。形如Content-Encoding: gzip<br>消息体是一个字符串，字符串的长度是由消息头部的Content-Length键指定的。如果没有Content-Length字段说明没有消息体，譬如GET请求就是没有消息体的，POST请求的消息体一般用来放置表单数据。GET请求的响应返回的页面内容也是放在消息体里面的。我们平时调用API返回的JSON内容都是放在消息体里面的。</p><h3 id="什么是分块传送？"><a href="#什么是分块传送？" class="headerlink" title="什么是分块传送？"></a>什么是分块传送？</h3><p>当浏览器向服务器请求一个资源时，这个资源是一个动态资源，服务器无法提前预知资源的大小，这个时候就可以使用分块传输。<br>服务器先生成一个thunk，发送这个chunk，再生成一个chunk，再发送一个chunk，直到全部资源传送完成。<br>分块传送需要在请求头增加一个特殊的键值对transfer-encoding: thunked，那么消息体的内容便是分块传送的。<br><img src="https://s3.bmp.ovh/imgs/2021/11/f08205bdbf44c61d.png" alt="alt 分块传送"><br>chunked传输格式如图所示，由一段一段的分块组合而成，每个块由一个长度行和一个分块体组成，最后一个分块长度为0表示结束。</p><h3 id="持久连接的机制是怎样的？"><a href="#持久连接的机制是怎样的？" class="headerlink" title="持久连接的机制是怎样的？"></a>持久连接的机制是怎样的？</h3><p>HTTP早期版本中每个请求都会发起一个连接，一个网页除了页面的HTML之外还会有很多静态资源以及诸多的API调用，如果每个请求都一个连接，势必网页的一次加载就会和服务器创建多次连接，这是非常浪费服务器资源的，同时也让客户端的访问速度慢了不少。HTTP1.0之后引入了Keep-Alive持久连接，在HTTP1.1版本中成为默认选项。它使得HTTP的一个连接可以连续服务多个请求，有效节省了资源，增加了客户端页面的加载速度。<br>持久连接也不宜一直保持，毕竟每个连接都会占用服务器资源，如果打开网页的人太多，那服务器资源也会紧张，所以一般服务器都会配置一个KeepAlive Timeout参数和KeepAlive Requests参数限制单个连接持续时长和最多服务的请求次数。<br>如果服务器设置的timeout时长为0，就退化到非持久连接。非持久连接会在响应头部增加一个头信息Connection: Close通知客户端在接受完当前响应后连接需要立即关闭。<br>同样浏览器也不会因为服务器将KeepAlive Timeout配置了无限长就不管不问一直持续保持连接。每个浏览器都有它自己的内置限制，具体限制浏览器厂商各有不同。</p><h3 id="如何理解HTTP协议的无状态性？"><a href="#如何理解HTTP协议的无状态性？" class="headerlink" title="如何理解HTTP协议的无状态性？"></a>如何理解HTTP协议的无状态性？</h3><p>所谓HTTP协议的无状态性是指服务器的协议层无需为不同的请求之间建立任何相关关系，它特指的是协议层的无状态性。但是这并不代表建立在HTTP协议之上的应用程序就无法维持状态。应用层可以通过会话Session来跟踪用户请求之间的相关性，服务器会为每个会话对象绑定一个唯一的会话ID，浏览器可以将会话ID记录在本地缓存LocalStorage或者Cookie，在后续的请求都带上这个会话ID，服务器就可以为每个请求找到相应的会话状态。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS中的层叠上下文和层叠顺序</title>
    <link href="/2021/11/26/stacking-context/"/>
    <url>/2021/11/26/stacking-context/</url>
    
    <content type="html"><![CDATA[<h2 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h2><h3 id="一、什么是层叠上下文"><a href="#一、什么是层叠上下文" class="headerlink" title="一、什么是层叠上下文"></a>一、什么是层叠上下文</h3><p>层叠上下文，英文称作”stacking context”. 是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元素在z轴上就“高人一等”。</p><p>这里出现了一个名词-z轴，指的是什么呢？</p><p>表示的是用户与屏幕的这条看不见的垂直线。</p><p>层叠上下文是一个概念，跟「块状格式化上下文(BFC)」类似。然而，概念这个东西是比较虚比较抽象的，要想轻松理解，我们需要将其具象化。</p><p>怎么个具象化法呢？</p><p>你可以把「层叠上下文」理解为当官：网页中有很多很多的元素，我们可以看成是真实世界的芸芸众生。真实世界里，我们大多数人是普通老百姓们，还有一部分人是做官的官员。OK，这里的“官员”就可以理解为网页中的层叠上下文元素。</p><p>换句话说，页面中的元素有了层叠上下文，就好比我们普通老百姓当了官，一旦当了官，相比普通老百姓而言，离皇帝更近了，对不对，就等同于网页中元素级别更高，离我们用户更近了。</p><h3 id="二、什么是层叠水平"><a href="#二、什么是层叠水平" class="headerlink" title="二、什么是层叠水平"></a>二、什么是层叠水平</h3><p>再来说说层叠水平。“层叠水平”英文称作”stacking level”，决定了同一个层叠上下文中元素在z轴上的显示顺序。level这个词很容易让我们联想到我们真正世界中的三六九等、论资排辈。真实世界中，每个人都是独立的个体，包括同卵双胞胎，有差异就有区分。例如，双胞胎虽然长得像Ctrl+C/Ctrl+V得到的，但实际上，出生时间还是有先后顺序的，先出生的那个就大，大哥或大姐。网页中的元素也是如此，页面中的每个元素都是独立的个体，他们一定是会有一个类似的排名排序的情况存在。而这个排名排序、论资排辈就是我们这里所说的“层叠水平”。层叠上下文元素的层叠水平可以理解为官员的职级，1品2品，县长省长之类；对于普通元素，这个嘛……你自己随意理解。</p><p>于是，显而易见，所有的元素都有层叠水平，包括层叠上下文元素，层叠上下文元素的层叠水平可以理解为官员的职级，1品2品，县长省长之类。然后，对于普通元素的层叠水平，我们的探讨仅仅局限在当前层叠上下文元素中。为什么呢？因为否则没有意义。</p><p>这么理解吧~ 上面提过元素具有层叠上下文好比当官，大家都知道的，这当官的家里都有丫鬟啊保镖啊管家啊什么的。所谓打狗看主人，A官员家里的管家和B官员家里的管家做PK实际上是没有意义的，因为他们牛不牛逼完全由他们的主子决定的。一人得道鸡犬升天，你说这和珅家里的管家和七侠镇娄知县县令家里的管家有可比性吗？李总理的秘书是不是分分钟灭了你村支部书记的秘书（如果有）。</p><p>翻译成术语就是：普通元素的层叠水平优先由层叠上下文决定，因此，层叠水平的比较只有在当前层叠上下文元素中才有意义。</p><p>需要注意的是，诸位千万不要把层叠水平和CSS的z-index属性混为一谈。没错，某些情况下z-index确实可以影响层叠水平，但是，只限于定位元素以及flex盒子的孩子元素；而层叠水平所有的元素都存在。</p><h3 id="三、什么是层叠顺序"><a href="#三、什么是层叠顺序" class="headerlink" title="三、什么是层叠顺序"></a>三、什么是层叠顺序</h3><p>再来说说层叠顺序。“层叠顺序”英文称作”stacking order”. 表示元素发生层叠时候有着特定的垂直显示顺序，注意，这里跟上面两个不一样，上面的层叠上下文和层叠水平是概念，而这里的层叠顺序是规则。</p><p>在CSS2.1的年代，在CSS3还没有出现的时候（注意这里的前提），层叠顺序规则遵循下面这张图：<br><img src="https://s3.bmp.ovh/imgs/2021/11/bdb573ccb36a3195.png" alt="alt 层叠顺序规则"><br>有人可能有见过类似图，那个图是很多很多年前老外绘制的，英文内容。而是更关键的是国内估计没有同行进行过验证与实践，实际上很多关键信息缺失。</p><p>缺失的关键信息包括：</p><ol><li>第一项 位于最低水平的 <kbd>border/background</kbd>指的是层叠上下文元素的边框和背景色。每一个层叠顺序规则适用于一个完整的层叠上下文元素。</li><li>原图没有呈现inline-block的层叠顺序，实际上，inline-block和inline水平元素是同等level级别。</li><li>z-index:0实际上和z-index:auto单纯从层叠水平上看，是可以看成是一样的。注意这里的措辞——“单纯从层叠水平上看”，实际上，两者在层叠上下文领域有着根本性的差异。<br>下面我要向大家发问了，大家有没有想过，为什么内联元素的层叠顺序要比浮动元素和块状元素都高？</li></ol><p>为什么呢？我明明感觉浮动元素和块状元素要更屌一点啊。</p><p>嘿嘿嘿，我就不卖关子了，直接看下图的标注说明：<br><img src="https://s3.bmp.ovh/imgs/2021/11/c2e53ebce4211353.png" alt="alt 层叠顺序规则"></p><p>诸如border/background一般为装饰属性，而浮动和块状元素一般用作布局，而内联元素都是内容。网页中最重要的是什么？当然是内容了哈，对不对！</p><p>因此，一定要让内容的层叠顺序相当高，当发生层叠是很好，重要的文字啊图片内容可以优先暴露在屏幕上。</p><h3 id="四、务必牢记的层叠准则"><a href="#四、务必牢记的层叠准则" class="headerlink" title="四、务必牢记的层叠准则"></a>四、务必牢记的层叠准则</h3><p>下面这两个是层叠领域的黄金准则。当元素发生层叠的时候，其覆盖关系遵循下面2个准则：</p><ol><li><b>谁大谁上：</b> 当具有明显的层叠水平标示的时候，如识别的z-indx值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。通俗讲就是官大的压死官小的。</li><li><b>后来居上：</b>当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</li></ol><p>在CSS和HTML领域，只要元素发生了重叠，都离不开上面这两个黄金准则。因为后面会有多个实例说明，这里就到此为止。</p><h3 id="五、层叠上下文的特性"><a href="#五、层叠上下文的特性" class="headerlink" title="五、层叠上下文的特性"></a>五、层叠上下文的特性</h3><p>层叠上下文元素有如下特性：</p><ul><li>层叠上下文的层叠水平要比普通元素高</li><li>层叠上下文可以阻断元素的混合模式</li><li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的层叠上下文。</li><li>每个层叠上下文和兄弟元素独立，也就是当进行层叠变化或渲染的时候，只需要考虑后代元素。</li><li>每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</li></ul><h3 id="六、层叠上下文的创建"><a href="#六、层叠上下文的创建" class="headerlink" title="六、层叠上下文的创建"></a>六、层叠上下文的创建</h3><p>卖了这么多文字，到底层叠上下文是个什么鬼，倒是拿出来瞅瞅啊！</p><p>哈哈。如同块状格式化上下文，层叠上下文也基本上是有一些特定的CSS属性创建的。我将其总结为3个流派，也就是做官的3种途径：</p><ol><li>皇亲国戚派：页面根元素天生具有层叠上下文，称之为“根层叠上下文”。</li><li>科考入选派：z-index值为数值的定位元素的传统层叠上下文。</li><li>其他当官途径：其他CSS3属性。</li></ol><h4 id="1-根层叠上下文"><a href="#1-根层叠上下文" class="headerlink" title="1. 根层叠上下文"></a>1. 根层叠上下文</h4><p>指的是页面根元素，也就是滚动条的默认的始作俑者<code>&lt;html&gt;</code>元素。这就是为什么，绝对定位元素在<code>left/top</code>等值定位的时候，如果没有其他定位元素限制，会相对浏览器窗口定位的原因。</p><h4 id="2-定位元素与传统层叠上下文"><a href="#2-定位元素与传统层叠上下文" class="headerlink" title="2. 定位元素与传统层叠上下文"></a>2. 定位元素与传统层叠上下文</h4><p>对于包含有<code>position:relative/position:absolute</code>的定位元素，以及FireFox/IE浏览器（不包括Chrome等webkit内核浏览器）（目前，也就是2016年初是这样）下含有<code>position:fixed</code>声明的定位元素，当其<code>z-index</code>值不是<code>auto</code>的时候，会创建层叠上下文。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;position:relative; z-index:auto;&quot;</span>&gt;<br>    &lt;img src=<span class="hljs-string">&quot;mm1.jpg&quot;</span> style=<span class="hljs-string">&quot;position:absolute; z-index:2;&quot;</span>&gt;    &lt;<span class="hljs-comment">-- 横妹子 --&gt;</span><br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;position:relative; z-index:auto;&quot;</span>&gt;<br>    &lt;img src=<span class="hljs-string">&quot;mm2.jpg&quot;</span> style=<span class="hljs-string">&quot;position:relative; z-index:1;&quot;</span>&gt;    &lt;<span class="hljs-comment">-- 竖妹子 --&gt;</span><br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2021/11/cd1fe1668945295e.png" alt="alt 层叠顺序规则"></p><p>大家会发现，竖着的妹子(mm2)被横着的妹子(mm1)给覆盖了。</p><p>下面，我们对父级简单调整下，把z-index:auto改成层叠水平一致的z-index:0, 代码如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;position:relative; z-index:0;&quot;</span>&gt;<br>    &lt;img src=<span class="hljs-string">&quot;mm1.jpg&quot;</span> style=<span class="hljs-string">&quot;position:absolute; z-index:2;&quot;</span>&gt;    &lt;<span class="hljs-comment">-- 横妹子 --&gt;</span><br>&lt;/<span class="hljs-keyword">div</span>&gt;<br>&lt;<span class="hljs-keyword">div</span> style=<span class="hljs-string">&quot;position:relative; z-index:0;&quot;</span>&gt;<br>    &lt;img src=<span class="hljs-string">&quot;mm2.jpg&quot;</span> style=<span class="hljs-string">&quot;position:relative; z-index:1;&quot;</span>&gt;    &lt;<span class="hljs-comment">-- 竖妹子 --&gt;</span><br>&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2021/11/212b18d02d746cc4.png" alt="alt 层叠顺序规则"></p><p>为什么小小的改变会有想法的结果呢？</p><p>差别就在于，<code>z-index:0</code>所在的<code>&lt;div&gt;</code>元素是层叠上下文元素，而<code>z-index:auto</code>所在的<code>&lt;div&gt;</code>元素是一个普通的元素，于是，里面的两个<code>&lt;img&gt;</code>妹子的层叠比较就不受父级的影响，两者直接套用层叠黄金准则，这里，两者有着明显不一的<code>z-index</code>值，因此，遵循<b>“谁大谁上”</b>的准则，于是，<code>z-index</code>为<code>2</code>的那个横妹子，就趴在了<code>z-index</code>为<code>1</code>的竖妹子身上。</p><p>而<code>z-index</code>一旦变成数值，哪怕是<code>0</code>，都会创建一个层叠上下文。此时，层叠规则就发生了变化。层叠上下文的特性里面最后一条——自成体系。两个<code>&lt;img&gt;</code>妹子的层叠顺序比较变成了优先比较其父级层叠上下文元素的层叠顺序。这里，由于两者都是<code>z-index:0</code>，层叠顺序这一块两者一样大，此时，遵循层叠黄金准则的另外一个准则<b>“后来居上”</b>，根据在DOM流中的位置决定谁在上面，于是，位于后面的竖着的妹子就自然而然趴在了横着的妹子身上。对，没错，<code>&lt;img&gt;</code>元素上的<code>z-index</code>打酱油了！</p><p>有时候，我们在网页重构的时候，会发现，<code>z-index</code>嵌套错乱，看看是不是受父级的层叠上下文元素干扰了。然后，可能没多大意义了，但我还是提一下，算是祭奠下，IE6/IE7浏览器有个bug，就是<code>z-index:auto</code>的定位元素也会创建层叠上下文。这就是为什么在过去，IE6/IE7的<code>z-index</code>会搞死人的原因。</p><p>然后，我再提一下<code>position:fixed</code>, 在过去，<code>position:fixed</code>和<code>relative/absolute</code>在层叠上下文这一块是一路货色，都是需要<code>z-index</code>为数值才行。但是，不知道什么时候起，Chrome等webkit内核浏览器，<code>position:fixed</code>元素天然层叠上下文元素，无需<code>z-index</code>为数值。根据我的测试，目前，IE以及FireFox仍是老套路。</p><h4 id="3-CSS3与新时代的层叠上下文"><a href="#3-CSS3与新时代的层叠上下文" class="headerlink" title="3. CSS3与新时代的层叠上下文"></a>3. CSS3与新时代的层叠上下文</h4><p>CSS3的出现除了带来了新属性，同时还对过去的很多规则发出了挑战。例如，CSS3 <code>transform</code>对<code>overflow</code>隐藏对<code>position:fixed</code>定位的影响等。而这里，层叠上下文这一块的影响要更加广泛与显著。</p><p>如下：</p><ol><li><code>z-index</code>值不为<code>auto</code>的<code>flex</code>项(父元素<code>display:flex|inline-flex</code>).</li><li>元素的<code>opacity</code>值不是<code>1</code>.</li><li>元素的<code>transform</code>值不是<code>none</code>.</li><li>元素<code>mix-blend-mode</code>值不是<code>normal</code>.</li><li>元素的<code>filter</code>值不是<code>none</code>.</li><li>元素的<code>isolation</code>值是<code>isolate</code>.</li><li><code>will-change</code>指定的属性值为上面任意一个。</li><li>元素的<code>-webkit-overflow-scrolling</code>设为<code>touch</code>.</li></ol><h3 id="七、结束语"><a href="#七、结束语" class="headerlink" title="七、结束语"></a>七、结束语</h3><p>只要元素发生层叠，要解释其表现，基本上就本文的这些内容了。</p><p>我发现很多重构小伙伴都有<code>z-index</code>滥用，或者使用不规范的问题。我觉得最主要的原因还是对理解层叠上下文以及层叠顺序这些概念都不了解。例如，只要使用了定位元素，尤其<code>absolute</code>绝对定位，都离不开设置一个<code>z-index</code>值；或者只要元素被其他元素覆盖了，例如变成定位元素或者增加<code>z-index</code>值升级。页面一复杂，必然搞得乱七八糟。</p><p>实际上，在我看来，觉得多数常见，<code>z-index</code>根本就没有出现的必要。知道了内联元素的层叠水平比块状元素高，于是，某条线你想覆盖上去的时候，需要设置<code>position:relative</code>吗？不需要，<code>inline-block</code>化就可以。因为IE6/IE7 <code>position:relative</code>会创建层叠上下文，很烦的。</p><p>OK，本文已经够长了，就不多啰嗦了。</p><p>行为匆忙，出错在所难免，欢迎大力指正。也欢迎各种形式的交流，或者指出文中概念性的错误。</p><p>感谢阅读！</p><p><a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/">参考地址</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/11/26/hello-world/"/>
    <url>/2021/11/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
